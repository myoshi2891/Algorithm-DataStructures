// 以下に、**Go 1.20.6** によるフィボナッチ数列の第 N 項を $10^9+7$ で割った余りを高速に求める実装を提示します。

// ---

// ## ✅ 実装方針

// | 項目    | 内容                      |
// | ----- | ----------------------- |
// | 時間計算量 | `O(N)`（1ループ）            |
// | 空間計算量 | `O(1)`（配列不使用）           |
// | 型の明示  | すべての関数と変数に明確な型を付与       |
// | メモリ効率 | スタック上の変数3つのみ使用          |
// | 入出力   | `fmt.Scan` を使用（高速 & 標準） |

// ---

// ## 🧮 Go (1.20.6) 実装コード

package main

import (
	"fmt"
)

const MOD int = 1_000_000_007

/**
 * fibonacciMod は、フィボナッチ数列の第 n 項を MOD(10^9+7) で割った余りを返します。
 *
 * @param n int フィボナッチ数列の項番号（3 <= n <= 10^7）
 * @return int 第 n 項を 10^9 + 7 で割った余り
 */
func fibonacciMod(n int) int {
	if n == 1 || n == 2 {
		return 1
	}

	var a, b int = 1, 1 // a: F(n-2), b: F(n-1)
	for i := 3; i <= n; i++ {
		next := (a + b) % MOD
		a = b
		b = next
	}
	return b
}

func main() {
	var n int
	_, err := fmt.Scan(&n)
	if err != nil {
		panic("入力エラー")
	}

	result := fibonacciMod(n)
	fmt.Println(result)
}

// ## ✅ 処理ステップの解説（図解）

// ```
// 初期状態:
// a = 1 (F₁)
// b = 1 (F₂)

// i = 3:
//   next = (a + b) % MOD = 2
//   a = 1, b = 2

// i = 4:
//   next = (1 + 2) % MOD = 3
//   a = 2, b = 3

// ...

// i = N:
//   結果は b（Fₙ）
// ```

// ---

// ## 📈 性能と制約対応

// | 性能項目   | 内容                        |
// | ------ | ------------------------- |
// | 時間計算量  | O(N)                      |
// | 空間計算量  | O(1)（変数3つのみ）              |
// | 実行時間   | N = 10^7 でも 0.2 ～ 0.5 秒程度 |
// | メモリ使用量 | 数十KB程度                    |
// | 対応制約   | `3 ≤ N ≤ 10^7` 完全対応       |

// ---

// ## 🧪 テスト例

// ### 入力

// ```
// 6
// ```

// ### 出力

// ```
// 8
// ```

// ---

// ## ✅ 実行方法

// ```bash
// go run main.go
// ```

// または、標準入力からの入力付きで：

// ```bash
// echo 8691200 | go run main.go
// ```

// ---

// ## ✅ 補足：高速化を希望する場合

// * `O(log N)` の **行列累乗法** や **Doubling法** による高速フィボナッチ計算も可能です。
// * ご希望があれば図付きでご案内します。

// ---

// 以上が Go (1.20.6) による、シンプルかつ高性能なフィボナッチ計算実装です。必要があれば高速バージョンの提供も可能です。

<!DOCTYPE html>
<html lang="ja">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>TypeScript数値検証アルゴリズム - 有限状態機械による型安全な実装</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
        <style>
            /* 
        ===== TypeScript数値検証アルゴリズム - 完全版インタラクティブデモ =====
        
        機能一覧:
        1. セクション折りたたみ/展開機能
        2. コードブロックコピー機能（成功フィードバック付き）
        3. スムーズスクロールナビゲーション
        4. レスポンシブメニュートグル機能
        5. ステップバイステップ制御システム
        6. 状態遷移アニメーション
        7. インタラクティブテストデモ
        8. パフォーマンス最適化済み
        
        対応ブラウザ: Chrome, Firefox, Safari, Edge
        モバイル対応: iOS Safari, Chrome Mobile
        */

            :root {
                --primary-bg: #0a0f1c;
                --secondary-bg: #1a2332;
                --accent-bg: #2d3748;
                --card-bg: #1e293b;
                --border-color: #374151;
                --text-primary: #f8fafc;
                --text-secondary: #94a3b8;
                --accent-color: #3b82f6;
                --accent-hover: #2563eb;
                --success-color: #10b981;
                --warning-color: #f59e0b;
                --error-color: #ef4444;
                --code-bg: #0f172a;
                --animation-speed: 1000ms;
            }

            body {
                font-family: 'Inter', system-ui, -apple-system, sans-serif;
                background: linear-gradient(135deg, var(--primary-bg) 0%, #1e293b 100%);
                color: var(--text-primary);
            }

            .code-font {
                font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            }

            .glass-effect {
                backdrop-filter: blur(10px);
                background: rgba(30, 41, 59, 0.7);
                border: 1px solid rgba(59, 130, 246, 0.2);
            }

            .gradient-border {
                position: relative;
                background: var(--card-bg);
                border-radius: 12px;
            }

            .gradient-border::before {
                content: '';
                position: absolute;
                inset: 0;
                padding: 2px;
                background: linear-gradient(45deg, #3b82f6, #8b5cf6, #06b6d4);
                border-radius: inherit;
                mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
                mask-composite: xor;
                -webkit-mask-composite: xor;
            }

            .hover-lift {
                transition: all 0.3s ease;
            }

            .hover-lift:hover {
                transform: translateY(-4px);
                box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
            }

            .code-block {
                background: var(--code-bg);
                border: 1px solid var(--border-color);
                border-radius: 8px;
                position: relative;
                overflow: hidden;
            }

            .line-numbers {
                background: #1e293b;
                color: #64748b;
                text-align: right;
                padding: 1rem 0.5rem;
                user-select: none;
                min-width: 3rem;
                border-right: 1px solid var(--border-color);
            }

            .code-content {
                padding: 1rem;
                overflow-x: auto;
                flex: 1;
            }

            .code-line {
                transition: all 0.3s ease;
                padding: 2px 0;
                border-radius: 4px;
            }

            .code-line:hover {
                background: rgba(59, 130, 246, 0.1);
            }

            .code-line.highlighted {
                background: rgba(59, 130, 246, 0.3);
                animation: pulse-highlight 1s ease-in-out;
            }

            @keyframes pulse-highlight {

                0%,
                100% {
                    background: rgba(59, 130, 246, 0.3);
                }

                50% {
                    background: rgba(59, 130, 246, 0.5);
                }
            }

            .syntax-keyword {
                color: #c792ea;
            }

            .syntax-string {
                color: #c3e88d;
            }

            .syntax-number {
                color: #f78c6c;
            }

            .syntax-comment {
                color: #546e7a;
                font-style: italic;
            }

            .syntax-function {
                color: #82aaff;
            }

            .syntax-operator {
                color: #89ddff;
            }

            .syntax-type {
                color: #ffcb6b;
            }

            .step-indicator {
                width: 2rem;
                height: 2rem;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 600;
                font-size: 0.875rem;
                transition: all 0.3s ease;
            }

            .step-active {
                background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                color: white;
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
                transform: scale(1.1);
            }

            .step-inactive {
                background: var(--accent-bg);
                color: var(--text-secondary);
            }

            .state-node {
                min-width: 120px;
                height: 60px;
                border-radius: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 500;
                font-size: 0.875rem;
                transition: all 0.5s ease;
                position: relative;
            }

            .state-initial {
                background: linear-gradient(135deg, #10b981, #047857);
            }

            .state-processing {
                background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            }

            .state-valid {
                background: linear-gradient(135deg, #10b981, #047857);
            }

            .state-invalid {
                background: linear-gradient(135deg, #ef4444, #dc2626);
            }

            .state-current {
                box-shadow: 0 0 20px rgba(59, 130, 246, 0.6);
                transform: scale(1.1);
            }

            .control-panel {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(45, 55, 72, 0.9));
                border: 1px solid var(--border-color);
                border-radius: 12px;
                backdrop-filter: blur(10px);
            }

            .control-btn {
                padding: 0.75rem;
                background: var(--accent-bg);
                border: 1px solid var(--border-color);
                border-radius: 8px;
                color: var(--text-primary);
                transition: all 0.2s ease;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .control-btn:hover {
                background: var(--accent-color);
                transform: scale(1.05);
            }

            .control-btn:active {
                transform: scale(0.95);
            }

            .control-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .control-btn:disabled:hover {
                transform: none;
                background: var(--accent-bg);
            }

            .speed-slider {
                -webkit-appearance: none;
                appearance: none;
                height: 4px;
                background: var(--accent-bg);
                border-radius: 2px;
                outline: none;
            }

            .speed-slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px;
                height: 20px;
                background: var(--accent-color);
                border-radius: 50%;
                cursor: pointer;
                border: 2px solid white;
            }

            .speed-slider::-moz-range-thumb {
                width: 20px;
                height: 20px;
                background: var(--accent-color);
                border-radius: 50%;
                cursor: pointer;
                border: 2px solid white;
            }

            .progress-bar {
                width: 100%;
                height: 8px;
                background: var(--accent-bg);
                border-radius: 4px;
                overflow: hidden;
            }

            .progress-fill {
                height: 100%;
                background: linear-gradient(90deg, #3b82f6, #8b5cf6);
                transition: width 0.3s ease;
            }

            .state-display {
                padding: 0.5rem 1rem;
                background: var(--accent-bg);
                border: 2px solid var(--border-color);
                border-radius: 8px;
                font-weight: 600;
                text-align: center;
                transition: all 0.3s ease;
            }

            .state-current {
                border-color: #3b82f6;
                background: rgba(59, 130, 246, 0.2);
                color: #93c5fd;
            }

            .char-box {
                display: inline-block;
                padding: 0.5rem;
                margin: 0.2rem;
                background: var(--accent-bg);
                border: 1px solid var(--border-color);
                border-radius: 4px;
                font-family: 'JetBrains Mono', monospace;
                font-size: 0.9rem;
                transition: all 0.3s ease;
            }

            .char-processed {
                background: rgba(16, 185, 129, 0.2);
                border-color: #10b981;
                color: #34d399;
            }

            .char-current {
                background: rgba(251, 191, 36, 0.3);
                border-color: #f59e0b;
                color: #fbbf24;
                transform: scale(1.1);
                box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
            }

            .char-pending {
                background: var(--accent-bg);
                color: var(--text-secondary);
            }

            .mobile-menu-hidden {
                transform: translateX(-100%);
            }

            .mobile-menu-visible {
                transform: translateX(0);
            }

            .section-content {
                max-height: 0;
                overflow: hidden;
                transition: all 0.5s ease;
                opacity: 0;
            }

            .section-content.expanded {
                max-height: none;
                opacity: 1;
            }

            .collapse-icon {
                transition: transform 0.3s ease;
            }

            .collapse-icon.rotated {
                transform: rotate(180deg);
            }

            .copy-feedback {
                position: absolute;
                top: 50%;
                right: 10px;
                transform: translateY(-50%);
                background: var(--success-color);
                color: white;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                font-size: 0.8rem;
                opacity: 0;
                transition: opacity 0.3s ease;
                pointer-events: none;
            }

            .copy-feedback.show {
                opacity: 1;
            }

            .test-case {
                transition: all 0.3s ease;
                cursor: pointer;
            }

            .test-case:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }

            @media (max-width: 768px) {
                .state-node {
                    min-width: 80px;
                    height: 40px;
                    font-size: 0.75rem;
                }

                .control-btn {
                    padding: 0.5rem;
                }

                .char-box {
                    padding: 0.3rem;
                    margin: 0.1rem;
                    font-size: 0.8rem;
                }
            }

            /* アクセシビリティ対応 */
            @media (prefers-reduced-motion: reduce) {
                * {
                    animation-duration: 0.01ms !important;
                    animation-iteration-count: 1 !important;
                    transition-duration: 0.01ms !important;
                }
            }

            /* ハイコントラスト対応 */
            @media (prefers-contrast: high) {
                .gradient-border::before {
                    background: #ffffff;
                }

                .code-line.highlighted {
                    background: rgba(255, 255, 255, 0.2);
                    border: 1px solid #ffffff;
                }
            }
        </style>
    </head>

    <body class="min-h-screen">
        <!-- Header -->
        <header class="glass-effect sticky top-0 z-50 border-b border-slate-700">
            <div class="container mx-auto px-6 py-4">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-4">
                        <div class="w-10 h-10 bg-gradient-to-br from-blue-500 to-purple-600 rounded-lg flex items-center justify-center">
                            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </div>
                        <div>
                            <h1 class="text-xl font-bold text-white">TypeScript数値検証</h1>
                            <p class="text-sm text-slate-400">有限状態機械による型安全な実装</p>
                        </div>
                    </div>
                    <button id="mobileMenuBtn" class="md:hidden p-2 rounded-lg hover:bg-slate-700 transition-colors" aria-label="メニューを開く">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </header>

        <div class="flex">
            <!-- Side Navigation -->
            <nav id="sideNav" class="fixed md:sticky top-0 left-0 h-full md:h-auto w-80 bg-slate-800 md:bg-transparent border-r border-slate-700 z-40 transform mobile-menu-hidden md:transform-none md:w-64 transition-transform duration-300 ease-in-out" role="navigation" aria-label="メインナビゲーション">
                <div class="p-6 space-y-6 mt-16 md:mt-0">
                    <div class="space-y-2">
                        <h3 class="text-sm font-semibold text-slate-400 uppercase tracking-wider">目次</h3>
                        <ul class="space-y-2">
                            <li><a href="#overview" class="nav-link block py-2 px-3 text-slate-300 hover:text-white hover:bg-slate-700 rounded-lg transition-colors">概要</a></li>
                            <li><a href="#algorithm" class="nav-link block py-2 px-3 text-slate-300 hover:text-white hover:bg-slate-700 rounded-lg transition-colors">アルゴリズム解説</a></li>
                            <li><a href="#state-machine" class="nav-link block py-2 px-3 text-slate-300 hover:text-white hover:bg-slate-700 rounded-lg transition-colors">状態遷移図</a></li>
                            <li><a href="#implementation" class="nav-link block py-2 px-3 text-slate-300 hover:text-white hover:bg-slate-700 rounded-lg transition-colors">実装詳細</a></li>
                            <li><a href="#complexity" class="nav-link block py-2 px-3 text-slate-300 hover:text-white hover:bg-slate-700 rounded-lg transition-colors">計算量解析</a></li>
                            <li><a href="#tests" class="nav-link block py-2 px-3 text-slate-300 hover:text-white hover:bg-slate-700 rounded-lg transition-colors">テスト例</a></li>
                        </ul>
                    </div>
                    <div class="space-y-2">
                        <h3 class="text-sm font-semibold text-slate-400 uppercase tracking-wider">特徴</h3>
                        <div class="space-y-1 text-sm text-slate-300">
                            <div class="flex items-center space-x-2">
                                <span class="w-2 h-2 bg-green-500 rounded-full"></span>
                                <span>型安全性</span>
                            </div>
                            <div class="flex items-center space-x-2">
                                <span class="w-2 h-2 bg-blue-500 rounded-full"></span>
                                <span>O(n)時間計算量</span>
                            </div>
                            <div class="flex items-center space-x-2">
                                <span class="w-2 h-2 bg-purple-500 rounded-full"></span>
                                <span>有限状態機械</span>
                            </div>
                            <div class="flex items-center space-x-2">
                                <span class="w-2 h-2 bg-yellow-500 rounded-full"></span>
                                <span>エラーハンドリング</span>
                            </div>
                        </div>
                    </div>
                </div>
            </nav>

            <!-- Overlay for mobile menu -->
            <div id="overlay" class="fixed inset-0 bg-black bg-opacity-50 z-30 hidden md:hidden" aria-hidden="true"></div>

            <!-- Main Content -->
            <main class="flex-1 min-h-screen" role="main">
                <div class="container mx-auto px-6 py-8 max-w-6xl">
                    <!-- Overview Section -->
                    <section id="overview" class="mb-16">
                        <div class="gradient-border hover-lift p-8">
                            <div class="section-header flex items-center justify-between mb-6 cursor-pointer" data-section="overview">
                                <h2 class="text-3xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                                    概要
                                </h2>
                                <svg class="collapse-icon w-6 h-6 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </div>
                            <div class="section-content expanded">
                                <div class="grid md:grid-cols-2 gap-8">
                                    <div>
                                        <p class="text-slate-300 leading-relaxed mb-6">
                                            このアルゴリズムは、TypeScriptの型システムを活用して文字列が有効な数値表現かどうかを判定します。
                                            有限状態機械（FSM）を用いることで、複雑な数値形式（整数、小数、指数表記）を効率的にパースできます。
                                        </p>
                                        <div class="space-y-4">
                                            <div class="flex items-center space-x-3">
                                                <div class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center">
                                                    <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                                    </svg>
                                                </div>
                                                <span class="text-slate-300">型安全なガード関数による文字分類</span>
                                            </div>
                                            <div class="flex items-center space-x-3">
                                                <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
                                                    <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                                    </svg>
                                                </div>
                                                <span class="text-slate-300">包括的なエラーハンドリング</span>
                                            </div>
                                            <div class="flex items-center space-x-3">
                                                <div class="w-8 h-8 bg-purple-500 rounded-full flex items-center justify-center">
                                                    <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                                    </svg>
                                                </div>
                                                <span class="text-slate-300">パフォーマンス最適化</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="bg-slate-800 rounded-lg p-6 border border-slate-600">
                                        <h4 class="font-semibold text-slate-200 mb-4">サポートする数値形式</h4>
                                        <div class="space-y-3 text-sm">
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">整数:</span>
                                                <code class="code-font text-green-400">123, -456, +789</code>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">小数:</span>
                                                <code class="code-font text-blue-400">3.14, -.5, 2.</code>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">指数表記:</span>
                                                <code class="code-font text-purple-400">1e10, -2E-3, +5e+7</code>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">複合形式:</span>
                                                <code class="code-font text-yellow-400">-123.45e-67</code>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <!-- Algorithm Section -->
                    <section id="algorithm" class="mb-16">
                        <div class="gradient-border hover-lift p-8">
                            <div class="section-header flex items-center justify-between mb-6 cursor-pointer" data-section="algorithm">
                                <h2 class="text-3xl font-bold bg-gradient-to-r from-green-400 to-blue-500 bg-clip-text text-transparent">
                                    アルゴリズム解説
                                </h2>
                                <svg class="collapse-icon w-6 h-6 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </div>
                            <div class="section-content expanded">
                                <!-- Interactive Animation Control Panel -->
                                <div class="control-panel p-6 mb-8">
                                    <h3 class="text-lg font-semibold text-slate-200 mb-4">ステップ実行デモ</h3>

                                    <!-- Input and Controls -->
                                    <div class="grid lg:grid-cols-2 gap-6 mb-6">
                                        <div>
                                            <label class="block text-sm font-medium text-slate-300 mb-2" for="animationInput">テスト文字列:</label>
                                            <input id="animationInput" type="text" value="123.45e-6" class="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder-slate-400 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none" aria-describedby="inputHelp">
                                            <div id="inputHelp" class="text-xs text-slate-400 mt-1">有効な数値形式を入力してください</div>
                                        </div>
                                        <div>
                                            <label class="block text-sm font-medium text-slate-300 mb-2" for="speedSlider">速度調整:</label>
                                            <div class="flex items-center space-x-3">
                                                <span class="text-sm text-slate-400">1x</span>
                                                <input id="speedSlider" type="range" min="1" max="5" value="2" class="speed-slider flex-1" aria-label="アニメーション速度">
                                                <span class="text-sm text-slate-400">5x</span>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Control Buttons -->
                                    <div class="flex items-center justify-center space-x-4 mb-6">
                                        <button id="resetBtn" class="control-btn" title="リセット" aria-label="アニメーションをリセット">
                                            <svg fill="currentColor" viewBox="0 0 20 20" class="w-5 h-5">
                                                <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"></path>
                                            </svg>
                                        </button>
                                        <button id="prevBtn" class="control-btn" title="前のステップ" aria-label="前のステップに戻る">
                                            <svg fill="currentColor" viewBox="0 0 20 20" class="w-5 h-5">
                                                <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                            </svg>
                                        </button>
                                        <button id="playBtn" class="control-btn" title="再生/停止" aria-label="アニメーション再生・停止">
                                            <svg id="playIcon" fill="currentColor" viewBox="0 0 20 20" class="w-5 h-5">
                                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path>
                                            </svg>
                                            <svg id="pauseIcon" fill="currentColor" viewBox="0 0 20 20" class="w-5 h-5 hidden">
                                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 002 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path>
                                            </svg>
                                        </button>
                                        <button id="nextBtn" class="control-btn" title="次のステップ" aria-label="次のステップに進む">
                                            <svg fill="currentColor" viewBox="0 0 20 20" class="w-5 h-5">
                                                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
                                            </svg>
                                        </button>
                                        <button id="fastBtn" class="control-btn" title="最後まで実行" aria-label="最後まで実行">
                                            <svg fill="currentColor" viewBox="0 0 20 20" class="w-5 h-5">
                                                <path d="M4.555 5.168A1 1 0 003 6v8a1 1 0 001.555.832L8 12.202V14a1 1 0 001.555.832l6-4a1 1 0 000-1.664l-6-4A1 1 0 008 6v1.798l-3.445-2.63z"></path>
                                            </svg>
                                        </button>
                                    </div>

                                    <!-- Progress Bar -->
                                    <div class="mb-4">
                                        <div class="flex justify-between text-sm text-slate-400 mb-2">
                                            <span>進行状況</span>
                                            <span id="progressText">0 / 0</span>
                                        </div>
                                        <div class="progress-bar">
                                            <div id="progressFill" class="progress-fill" style="width: 0%" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                                        </div>
                                    </div>

                                    <!-- Current Step Info -->
                                    <div id="stepInfo" class="bg-slate-800 rounded-lg p-4 border border-slate-600">
                                        <div class="grid md:grid-cols-2 gap-4">
                                            <div>
                                                <h5 class="text-sm font-medium text-slate-300 mb-2">現在の状態:</h5>
                                                <div id="currentState" class="state-display state-current">INITIAL</div>
                                            </div>
                                            <div>
                                                <h5 class="text-sm font-medium text-slate-300 mb-2">処理中の文字:</h5>
                                                <div id="currentChar" class="state-display" style="border-color: #f59e0b; color: #fbbf24;">-</div>
                                            </div>
                                        </div>
                                        <div class="mt-4">
                                            <h5 class="text-sm font-medium text-slate-300 mb-2">文字列の状態:</h5>
                                            <div id="stringVisualization" class="flex flex-wrap items-center p-3 bg-slate-700 rounded-lg min-h-[60px]">
                                                <!-- Characters will be dynamically inserted here -->
                                            </div>
                                        </div>
                                        <div class="mt-4">
                                            <h5 class="text-sm font-medium text-slate-300 mb-2">説明:</h5>
                                            <p id="stepDescription" class="text-sm text-slate-400">アルゴリズムの実行を開始してください</p>
                                        </div>
                                    </div>
                                </div>

                                <div class="grid lg:grid-cols-2 gap-8">
                                    <div class="space-y-6">
                                        <div class="bg-slate-800 rounded-lg p-6 border border-slate-600">
                                            <h4 class="font-semibold text-slate-200 mb-4">処理ステップ</h4>
                                            <div class="space-y-4">
                                                <div class="flex items-start space-x-4">
                                                    <div class="step-indicator step-active">1</div>
                                                    <div>
                                                        <h5 class="font-medium text-slate-200">入力検証</h5>
                                                        <p class="text-sm text-slate-400">型チェックと制約検証</p>
                                                    </div>
                                                </div>
                                                <div class="flex items-start space-x-4">
                                                    <div class="step-indicator step-active">2</div>
                                                    <div>
                                                        <h5 class="font-medium text-slate-200">状態初期化</h5>
                                                        <p class="text-sm text-slate-400">INITIAL状態でスタート</p>
                                                    </div>
                                                </div>
                                                <div class="flex items-start space-x-4">
                                                    <div class="step-indicator step-active">3</div>
                                                    <div>
                                                        <h5 class="font-medium text-slate-200">文字単位処理</h5>
                                                        <p class="text-sm text-slate-400">各文字に対して状態遷移</p>
                                                    </div>
                                                </div>
                                                <div class="flex items-start space-x-4">
                                                    <div class="step-indicator step-active">4</div>
                                                    <div>
                                                        <h5 class="font-medium text-slate-200">終了状態判定</h5>
                                                        <p class="text-sm text-slate-400">有効な終了状態かチェック</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bg-gradient-to-br from-blue-900 to-purple-900 rounded-lg p-6 border border-blue-500">
                                            <h4 class="font-semibold text-blue-100 mb-3">型安全性の特徴</h4>
                                            <ul class="space-y-2 text-sm text-blue-200">
                                                <li>• Union型による状態管理</li>
                                                <li>• 型ガード関数で文字分類</li>
                                                <li>• Exhaustive switchによる網羅性保証</li>
                                                <li>• アサーション関数による入力検証</li>
                                            </ul>
                                        </div>
                                    </div>
                                    <div class="space-y-6">
                                        <div class="code-block">
                                            <div class="flex items-center justify-between bg-slate-700 px-4 py-2 border-b border-slate-600">
                                                <span class="text-sm font-medium text-slate-200">メイン関数シグネチャ</span>
                                                <button class="copy-btn p-2 hover:bg-slate-600 rounded transition-colors" data-copy-target="main-function" aria-label="コードをコピー">
                                                    <svg class="w-4 h-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                                    </svg>
                                                </button>
                                                <div class="copy-feedback">コピーしました！</div>
                                            </div>
                                            <div class="flex">
                                                <div class="line-numbers">
                                                    <div>1</div>
                                                    <div>2</div>
                                                    <div>3</div>
                                                    <div>4</div>
                                                    <div>5</div>
                                                </div>
                                                <div id="main-function" class="code-content code-font text-sm">
                                                    <div class="code-line"><span class="syntax-keyword">function</span> <span class="syntax-function">isNumber</span><span class="syntax-operator">(</span></div>
                                                    <div class="code-line"> <span class="syntax-string">s</span><span class="syntax-operator">:</span> <span class="syntax-type">string</span><span class="syntax-operator">,</span></div>
                                                    <div class="code-line"> <span class="syntax-string">options</span><span class="syntax-operator">:</span> <span class="syntax-type">ValidationOptions</span> <span class="syntax-operator">=</span> <span class="syntax-operator">{}</span></div>
                                                    <div class="code-line"><span class="syntax-operator">):</span> <span class="syntax-type">boolean</span> <span class="syntax-operator">{</span></div>
                                                    <div class="code-line"> <span class="syntax-comment">// 実装...</span></div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bg-slate-800 rounded-lg p-6 border border-slate-600">
                                            <h4 class="font-semibold text-slate-200 mb-4">パフォーマンス指標</h4>
                                            <div class="grid grid-cols-2 gap-4 text-center">
                                                <div class="bg-green-900 rounded-lg p-4">
                                                    <div class="text-2xl font-bold text-green-400">O(n)</div>
                                                    <div class="text-sm text-green-200">時間計算量</div>
                                                </div>
                                                <div class="bg-blue-900 rounded-lg p-4">
                                                    <div class="text-2xl font-bold text-blue-400">O(1)</div>
                                                    <div class="text-sm text-blue-200">空間計算量</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <!-- State Machine Section -->
                    <section id="state-machine" class="mb-16">
                        <div class="gradient-border hover-lift p-8">
                            <div class="section-header flex items-center justify-between mb-6 cursor-pointer" data-section="state-machine">
                                <h2 class="text-3xl font-bold bg-gradient-to-r from-purple-400 to-pink-500 bg-clip-text text-transparent">
                                    状態遷移図
                                </h2>
                                <svg class="collapse-icon w-6 h-6 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </div>
                            <div class="section-content expanded">
                                <div class="bg-slate-900 rounded-lg p-8 border border-slate-600 overflow-x-auto">
                                    <svg viewBox="0 0 1200 600" class="w-full h-auto min-w-[800px]">
                                        <defs>
                                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                                <polygon points="0 0, 10 3.5, 0 7" fill="#64748b" />
                                            </marker>
                                        </defs>

                                        <!-- States -->
                                        <g class="states">
                                            <!-- INITIAL -->
                                            <ellipse cx="100" cy="100" rx="80" ry="40" class="state-initial" />
                                            <text x="100" y="105" text-anchor="middle" class="fill-white text-sm font-medium">INITIAL</text>

                                            <!-- SIGN -->
                                            <ellipse cx="300" cy="100" rx="60" ry="30" class="state-processing" />
                                            <text x="300" y="105" text-anchor="middle" class="fill-white text-xs font-medium">SIGN</text>

                                            <!-- INTEGER -->
                                            <ellipse cx="500" cy="100" rx="80" ry="40" class="state-valid" />
                                            <text x="500" y="105" text-anchor="middle" class="fill-white text-sm font-medium">INTEGER</text>

                                            <!-- DOT -->
                                            <ellipse cx="300" cy="250" rx="50" ry="30" class="state-processing" />
                                            <text x="300" y="255" text-anchor="middle" class="fill-white text-xs font-medium">DOT</text>

                                            <!-- DECIMAL -->
                                            <ellipse cx="500" cy="250" rx="80" ry="40" class="state-valid" />
                                            <text x="500" y="255" text-anchor="middle" class="fill-white text-sm font-medium">DECIMAL</text>

                                            <!-- EXP -->
                                            <ellipse cx="700" cy="175" rx="50" ry="30" class="state-processing" />
                                            <text x="700" y="180" text-anchor="middle" class="fill-white text-xs font-medium">EXP</text>

                                            <!-- EXP_SIGN -->
                                            <ellipse cx="850" cy="175" rx="70" ry="30" class="state-processing" />
                                            <text x="850" y="180" text-anchor="middle" class="fill-white text-xs font-medium">EXP_SIGN</text>

                                            <!-- EXP_NUMBER -->
                                            <ellipse cx="1000" cy="175" rx="90" ry="40" class="state-valid" />
                                            <text x="1000" y="180" text-anchor="middle" class="fill-white text-sm font-medium">EXP_NUMBER</text>
                                        </g>

                                        <!-- Arrows -->
                                        <g class="arrows">
                                            <!-- INITIAL to SIGN -->
                                            <path d="M 180 100 L 240 100" class="flow-arrow" />
                                            <text x="210" y="90" text-anchor="middle" class="fill-slate-400 text-xs">+/-</text>

                                            <!-- INITIAL to INTEGER -->
                                            <path d="M 180 80 Q 340 50 420 80" class="flow-arrow" />
                                            <text x="300" y="60" text-anchor="middle" class="fill-slate-400 text-xs">digit</text>

                                            <!-- INITIAL to DOT -->
                                            <path d="M 140 140 L 260 220" class="flow-arrow" />
                                            <text x="200" y="190" text-anchor="middle" class="fill-slate-400 text-xs">.</text>

                                            <!-- SIGN to INTEGER -->
                                            <path d="M 360 100 L 420 100" class="flow-arrow" />
                                            <text x="390" y="90" text-anchor="middle" class="fill-slate-400 text-xs">digit</text>

                                            <!-- SIGN to DOT -->
                                            <path d="M 300 130 L 300 220" class="flow-arrow" />
                                            <text x="320" y="175" text-anchor="middle" class="fill-slate-400 text-xs">.</text>

                                            <!-- INTEGER to DECIMAL -->
                                            <path d="M 500 140 L 500 210" class="flow-arrow" />
                                            <text x="520" y="175" text-anchor="middle" class="fill-slate-400 text-xs">.</text>

                                            <!-- DOT to DECIMAL -->
                                            <path d="M 350 250 L 420 250" class="flow-arrow" />
                                            <text x="385" y="240" text-anchor="middle" class="fill-slate-400 text-xs">digit</text>

                                            <!-- INTEGER to EXP -->
                                            <path d="M 570 120 L 650 160" class="flow-arrow" />
                                            <text x="610" y="130" text-anchor="middle" class="fill-slate-400 text-xs">e/E</text>

                                            <!-- DECIMAL to EXP -->
                                            <path d="M 570 230 L 650 190" class="flow-arrow" />
                                            <text x="610" y="220" text-anchor="middle" class="fill-slate-400 text-xs">e/E</text>

                                            <!-- EXP to EXP_SIGN -->
                                            <path d="M 750 175 L 780 175" class="flow-arrow" />
                                            <text x="765" y="165" text-anchor="middle" class="fill-slate-400 text-xs">+/-</text>

                                            <!-- EXP to EXP_NUMBER -->
                                            <path d="M 740 155 Q 870 130 920 155" class="flow-arrow" />
                                            <text x="830" y="135" text-anchor="middle" class="fill-slate-400 text-xs">digit</text>

                                            <!-- EXP_SIGN to EXP_NUMBER -->
                                            <path d="M 920 175 L 910 175" class="flow-arrow" />
                                            <text x="965" y="165" text-anchor="middle" class="fill-slate-400 text-xs">digit</text>

                                            <!-- Self loops -->
                                            <path d="M 500 60 Q 540 40 500 60" class="flow-arrow" />
                                            <text x="520" y="35" text-anchor="middle" class="fill-slate-400 text-xs">digit</text>

                                            <path d="M 500 210 Q 540 190 500 210" class="flow-arrow" />
                                            <text x="520" y="185" text-anchor="middle" class="fill-slate-400 text-xs">digit</text>

                                            <path d="M 1000 135 Q 1040 115 1000 135" class="flow-arrow" />
                                            <text x="1020" y="110" text-anchor="middle" class="fill-slate-400 text-xs">digit</text>
                                        </g>

                                        <!-- Legend -->
                                        <g class="legend" transform="translate(50, 400)">
                                            <rect x="0" y="0" width="400" height="150" rx="8" class="fill-slate-800 stroke-slate-600" />
                                            <text x="20" y="25" class="fill-slate-200 text-sm font-medium">状態の説明</text>

                                            <circle cx="30" cy="50" r="10" class="state-initial" />
                                            <text x="50" y="55" class="fill-slate-300 text-xs">初期状態・有効終了状態</text>

                                            <circle cx="30" cy="75" r="10" class="state-processing" />
                                            <text x="50" y="80" class="fill-slate-300 text-xs">中間状態（無効終了）</text>

                                            <circle cx="30" cy="100" r="10" class="state-valid" />
                                            <text x="50" y="105" class="fill-slate-300 text-xs">有効終了状態</text>

                                            <text x="20" y="130" class="fill-slate-400 text-xs">矢印: 状態遷移条件</text>
                                        </g>
                                    </svg>
                                </div>

                                <div class="mt-8 grid md:grid-cols-2 gap-6">
                                    <div class="bg-slate-800 rounded-lg p-6 border border-slate-600">
                                        <h4 class="font-semibold text-slate-200 mb-4">状態定義</h4>
                                        <div class="space-y-3 text-sm">
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">INITIAL:</span>
                                                <span class="text-slate-200">開始状態</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">SIGN:</span>
                                                <span class="text-slate-200">符号読み取り後</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">INTEGER:</span>
                                                <span class="text-green-400">整数部（有効終了）</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">DOT:</span>
                                                <span class="text-slate-200">小数点読み取り後</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">DECIMAL:</span>
                                                <span class="text-green-400">小数部（有効終了）</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">EXP:</span>
                                                <span class="text-slate-200">指数記号読み取り後</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">EXP_SIGN:</span>
                                                <span class="text-slate-200">指数符号読み取り後</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-slate-400">EXP_NUMBER:</span>
                                                <span class="text-green-400">指数部（有効終了）</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="bg-gradient-to-br from-green-900 to-blue-900 rounded-lg p-6 border border-green-500">
                                        <h4 class="font-semibold text-green-100 mb-4">有効終了状態</h4>
                                        <p class="text-sm text-green-200 mb-4">
                                            文字列の終端で以下の状態にいる場合のみ、有効な数値と判定されます：
                                        </p>
                                        <ul class="space-y-2 text-sm text-green-200">
                                            <li class="flex items-center space-x-2">
                                                <span class="w-2 h-2 bg-green-400 rounded-full"></span>
                                                <code class="code-font">INTEGER</code>
                                                <span>- 整数形式</span>
                                            </li>
                                            <li class="flex items-center space-x-2">
                                                <span class="w-2 h-2 bg-green-400 rounded-full"></span>
                                                <code class="code-font">DECIMAL</code>
                                                <span>- 小数形式</span>
                                            </li>
                                            <li class="flex items-center space-x-2">
                                                <span class="w-2 h-2 bg-green-400 rounded-full"></span>
                                                <code class="code-font">EXP_NUMBER</code>
                                                <span>- 指数形式</span>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <!-- Implementation Section -->
                    <section id="implementation" class="mb-16">
                        <div class="gradient-border hover-lift p-8">
                            <div class="section-header flex items-center justify-between mb-6 cursor-pointer" data-section="implementation">
                                <h2 class="text-3xl font-bold bg-gradient-to-r from-yellow-400 to-red-500 bg-clip-text text-transparent">
                                    実装詳細
                                </h2>
                                <svg class="collapse-icon w-6 h-6 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </div>
                            <div class="section-content expanded">
                                <!-- Type Guards -->
                                <div class="mb-8">
                                    <h3 class="text-xl font-semibold text-slate-200 mb-4">型ガード関数</h3>
                                    <div class="code-block">
                                        <div class="flex items-center justify-between bg-slate-700 px-4 py-2 border-b border-slate-600">
                                            <span class="text-sm font-medium text-slate-200">型安全な文字分類関数</span>
                                            <button class="copy-btn p-2 hover:bg-slate-600 rounded transition-colors" data-copy-target="type-guards" aria-label="コードをコピー">
                                                <svg class="w-4 h-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                                </svg>
                                            </button>
                                            <div class="copy-feedback">コピーしました！</div>
                                        </div>
                                        <div class="flex">
                                            <div class="line-numbers">
                                                <div>1</div>
                                                <div>2</div>
                                                <div>3</div>
                                                <div>4</div>
                                                <div>5</div>
                                                <div>6</div>
                                                <div>7</div>
                                                <div>8</div>
                                                <div>9</div>
                                                <div>10</div>
                                                <div>11</div>
                                                <div>12</div>
                                            </div>
                                            <div id="type-guards" class="code-content code-font text-sm">
                                                <div class="code-line"><span class="syntax-comment">// 数字判定（型ガード）</span></div>
                                                <div class="code-line"><span class="syntax-keyword">const</span> <span class="syntax-function">isDigit</span> <span class="syntax-operator">=</span> <span class="syntax-operator">(</span><span class="syntax-string">char</span><span class="syntax-operator">:</span> <span class="syntax-type">string</span><span class="syntax-operator">):</span> <span class="syntax-string">char</span> <span class="syntax-keyword">is</span> <span class="syntax-string">'0'</span> <span class="syntax-operator">|</span> <span class="syntax-string">'1'</span> <span class="syntax-operator">|</span> <span class="syntax-operator">...</span> <span class="syntax-operator">=></span> <span class="syntax-operator">{</span></div>
                                                <div class="code-line"> <span class="syntax-keyword">return</span> <span class="syntax-string">char</span> <span class="syntax-operator">>=</span> <span class="syntax-string">'0'</span> <span class="syntax-operator">&&</span> <span class="syntax-string">char</span> <span class="syntax-operator">
                                                        <=< /span> <span class="syntax-string">'9'</span><span class="syntax-operator">;</span></div>
                                                <div class="code-line"><span class="syntax-operator">};</span></div>
                                                <div class="code-line"></div>
                                                <div class="code-line"><span class="syntax-comment">// 符号判定（型ガード）</span></div>
                                                <div class="code-line"><span class="syntax-keyword">const</span> <span class="syntax-function">isSign</span> <span class="syntax-operator">=</span> <span class="syntax-operator">(</span><span class="syntax-string">char</span><span class="syntax-operator">:</span> <span class="syntax-type">string</span><span class="syntax-operator">):</span> <span class="syntax-string">char</span> <span class="syntax-keyword">is</span> <span class="syntax-string">'+'</span> <span class="syntax-operator">|</span> <span class="syntax-string">'-'</span> <span class="syntax-operator">=></span> <span class="syntax-operator">{</span></div>
                                                <div class="code-line"> <span class="syntax-keyword">return</span> <span class="syntax-string">char</span> <span class="syntax-operator">===</span> <span class="syntax-string">'+'</span> <span class="syntax-operator">||</span> <span class="syntax-string">char</span> <span class="syntax-operator">===</span> <span class="syntax-string">'-'</span><span class="syntax-operator">;</span></div>
                                                <div class="code-line"><span class="syntax-operator">};</span></div>
                                                <div class="code-line"></div>
                                                <div class="code-line"><span class="syntax-comment">// 指数記号判定（型ガード）</span></div>
                                                <div class="code-line"><span class="syntax-keyword">const</span> <span class="syntax-function">isExp</span> <span class="syntax-operator">=</span> <span class="syntax-operator">(</span><span class="syntax-string">char</span><span class="syntax-operator">:</span> <span class="syntax-type">string</span><span class="syntax-operator">):</span> <span class="syntax-string">char</span> <span class="syntax-keyword">is</span> <span class="syntax-string">'e'</span> <span class="syntax-operator">|</span> <span class="syntax-string">'E'</span> <span class="syntax-operator">=></span> <span class="syntax-operator">{</span></div>
                                                <div class="code-line"> <span class="syntax-keyword">return</span> <span class="syntax-string">char</span> <span class="syntax-operator">===</span> <span class="syntax-string">'e'</span> <span class="syntax-operator">||</span> <span class="syntax-string">char</span> <span class="syntax-operator">===</span> <span class="syntax-string">'E'</span><span class="syntax-operator">;</span></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Main Algorithm -->
                                <div class="mb-8">
                                    <h3 class="text-xl font-semibold text-slate-200 mb-4">メインアルゴリズム</h3>
                                    <div class="code-block">
                                        <div class="flex items-center justify-between bg-slate-700 px-4 py-2 border-b border-slate-600">
                                            <span class="text-sm font-medium text-slate-200">状態遷移処理（抜粋）</span>
                                            <button class="copy-btn p-2 hover:bg-slate-600 rounded transition-colors" data-copy-target="main-algorithm" aria-label="コードをコピー">
                                                <svg class="w-4 h-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                                </svg>
                                            </button>
                                            <div class="copy-feedback">コピーしました！</div>
                                        </div>
                                        <div class="flex">
                                            <div class="line-numbers">
                                                <div>1</div>
                                                <div>2</div>
                                                <div>3</div>
                                                <div>4</div>
                                                <div>5</div>
                                                <div>6</div>
                                                <div>7</div>
                                                <div>8</div>
                                                <div>9</div>
                                                <div>10</div>
                                                <div>11</div>
                                                <div>12</div>
                                                <div>13</div>
                                                <div>14</div>
                                                <div>15</div>
                                                <div>16</div>
                                                <div>17</div>
                                                <div>18</div>
                                            </div>
                                            <div id="main-algorithm" class="code-content code-font text-sm">
                                                <div class="code-line"><span class="syntax-comment">// メインループ</span></div>
                                                <div class="code-line"><span class="syntax-keyword">while</span> <span class="syntax-operator">(</span><span class="syntax-string">i</span> <span class="syntax-operator">
                                                        << /span> <span class="syntax-string">len</span><span class="syntax-operator">)</span> <span class="syntax-operator">{</span></div>
                                                <div class="code-line"> <span class="syntax-keyword">const</span> <span class="syntax-string">char</span><span class="syntax-operator">:</span> <span class="syntax-type">string</span> <span class="syntax-operator">=</span> <span class="syntax-string">s</span><span class="syntax-operator">[</span><span class="syntax-string">i</span><span class="syntax-operator">];</span></div>
                                                <div class="code-line"></div>
                                                <div class="code-line"> <span class="syntax-keyword">switch</span> <span class="syntax-operator">(</span><span class="syntax-string">state</span><span class="syntax-operator">)</span> <span class="syntax-operator">{</span></div>
                                                <div class="code-line"> <span class="syntax-keyword">case</span> <span class="syntax-string">State</span><span class="syntax-operator">.</span><span class="syntax-string">INITIAL</span><span class="syntax-operator">:</span></div>
                                                <div class="code-line"> <span class="syntax-keyword">if</span> <span class="syntax-operator">(</span><span class="syntax-function">isSign</span><span class="syntax-operator">(</span><span class="syntax-string">char</span><span class="syntax-operator">))</span> <span class="syntax-operator">{</span></div>
                                                <div class="code-line"> <span class="syntax-string">state</span> <span class="syntax-operator">=</span> <span class="syntax-string">State</span><span class="syntax-operator">.</span><span class="syntax-string">SIGN</span><span class="syntax-operator">;</span></div>
                                                <div class="code-line"> <span class="syntax-operator">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">if</span> <span class="syntax-operator">(</span><span class="syntax-function">isDigit</span><span class="syntax-operator">(</span><span class="syntax-string">char</span><span class="syntax-operator">))</span> <span class="syntax-operator">{</span></div>
                                                <div class="code-line"> <span class="syntax-string">state</span> <span class="syntax-operator">=</span> <span class="syntax-string">State</span><span class="syntax-operator">.</span><span class="syntax-string">INTEGER</span><span class="syntax-operator">;</span></div>
                                                <div class="code-line"> <span class="syntax-operator">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">if</span> <span class="syntax-operator">(</span><span class="syntax-string">char</span> <span class="syntax-operator">===</span> <span class="syntax-string">'.'</span><span class="syntax-operator">)</span> <span class="syntax-operator">{</span></div>
                                                <div class="code-line"> <span class="syntax-string">state</span> <span class="syntax-operator">=</span> <span class="syntax-string">State</span><span class="syntax-operator">.</span><span class="syntax-string">DOT</span><span class="syntax-operator">;</span></div>
                                                <div class="code-line"> <span class="syntax-operator">}</span> <span class="syntax-keyword">else</span> <span class="syntax-operator">{</span></div>
                                                <div class="code-line"> <span class="syntax-keyword">return</span> <span class="syntax-keyword">false</span><span class="syntax-operator">;</span></div>
                                                <div class="code-line"> <span class="syntax-operator">}</span></div>
                                                <div class="code-line"> <span class="syntax-keyword">break</span><span class="syntax-operator">;</span></div>
                                                <div class="code-line"> <span class="syntax-comment">// 他の状態...</span></div>
                                                <div class="code-line"> <span class="syntax-operator">}</span></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Error Handling -->
                                <div class="grid md:grid-cols-2 gap-6">
                                    <div class="bg-red-900 bg-opacity-30 rounded-lg p-6 border border-red-500">
                                        <h4 class="font-semibold text-red-200 mb-4">エラーハンドリング</h4>
                                        <ul class="space-y-2 text-sm text-red-200">
                                            <li>• 型安全性: アサーション関数による入力検証</li>
                                            <li>• 制約チェック: 長さ制限（最大20文字）</li>
                                            <li>• 厳密モード: オプションでエラー伝播</li>
                                            <li>• 網羅性: exhaustive switchパターン</li>
                                        </ul>
                                    </div>
                                    <div class="bg-blue-900 bg-opacity-30 rounded-lg p-6 border border-blue-500">
                                        <h4 class="font-semibold text-blue-200 mb-4">最適化技術</h4>
                                        <ul class="space-y-2 text-sm text-blue-200">
                                            <li>• インライン化: 小関数の最適化促進</li>
                                            <li>• 型ガード: 実行時型チェック最小化</li>
                                            <li>• インデックスアクセス: charAt()より高速</li>
                                            <li>• 状態最小化: 不要な状態変更回避</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <!-- Complexity Analysis -->
                    <section id="complexity" class="mb-16">
                        <div class="gradient-border hover-lift p-8">
                            <div class="section-header flex items-center justify-between mb-6 cursor-pointer" data-section="complexity">
                                <h2 class="text-3xl font-bold bg-gradient-to-r from-cyan-400 to-blue-500 bg-clip-text text-transparent">
                                    計算量解析
                                </h2>
                                <svg class="collapse-icon w-6 h-6 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </div>
                            <div class="section-content expanded">
                                <div class="grid lg:grid-cols-2 gap-8">
                                    <div class="space-y-6">
                                        <div class="bg-green-900 bg-opacity-30 rounded-lg p-6 border border-green-500">
                                            <h3 class="text-xl font-semibold text-green-200 mb-4">時間計算量: O(n)</h3>
                                            <div class="space-y-4">
                                                <div class="flex items-start space-x-3">
                                                    <span class="w-2 h-2 bg-green-400 rounded-full mt-2"></span>
                                                    <div>
                                                        <p class="text-green-200 font-medium">線形スキャン</p>
                                                        <p class="text-sm text-green-300">文字列を一度だけ左から右へ走査</p>
                                                    </div>
                                                </div>
                                                <div class="flex items-start space-x-3">
                                                    <span class="w-2 h-2 bg-green-400 rounded-full mt-2"></span>
                                                    <div>
                                                        <p class="text-green-200 font-medium">定数時間操作</p>
                                                        <p class="text-sm text-green-300">各文字の処理は O(1) 時間</p>
                                                    </div>
                                                </div>
                                                <div class="flex items-start space-x-3">
                                                    <span class="w-2 h-2 bg-green-400 rounded-full mt-2"></span>
                                                    <div>
                                                        <p class="text-green-200 font-medium">最適な効率性</p>
                                                        <p class="text-sm text-green-300">理論的下限値に到達</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <div class="bg-blue-900 bg-opacity-30 rounded-lg p-6 border border-blue-500">
                                            <h3 class="text-xl font-semibold text-blue-200 mb-4">空間計算量: O(1)</h3>
                                            <div class="space-y-4">
                                                <div class="flex items-start space-x-3">
                                                    <span class="w-2 h-2 bg-blue-400 rounded-full mt-2"></span>
                                                    <div>
                                                        <p class="text-blue-200 font-medium">固定メモリ使用</p>
                                                        <p class="text-sm text-blue-300">入力サイズに関係なく一定</p>
                                                    </div>
                                                </div>
                                                <div class="flex items-start space-x-3">
                                                    <span class="w-2 h-2 bg-blue-400 rounded-full mt-2"></span>
                                                    <div>
                                                        <p class="text-blue-200 font-medium">状態変数のみ</p>
                                                        <p class="text-sm text-blue-300">追加データ構造不要</p>
                                                    </div>
                                                </div>
                                                <div class="flex items-start space-x-3">
                                                    <span class="w-2 h-2 bg-blue-400 rounded-full mt-2"></span>
                                                    <div>
                                                        <p class="text-blue-200 font-medium">メモリ効率的</p>
                                                        <p class="text-sm text-blue-300">大規模データに適用可能</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="space-y-6">
                                        <div class="bg-slate-800 rounded-lg p-6 border border-slate-600">
                                            <h4 class="font-semibold text-slate-200 mb-4">パフォーマンス比較</h4>
                                            <div class="space-y-4">
                                                <div class="flex justify-between items-center">
                                                    <span class="text-slate-300">正規表現アプローチ</span>
                                                    <div class="flex items-center space-x-2">
                                                        <div class="w-16 bg-slate-600 h-2 rounded-full">
                                                            <div class="w-12 bg-red-500 h-2 rounded-full"></div>
                                                        </div>
                                                        <span class="text-sm text-red-400">遅い</span>
                                                    </div>
                                                </div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-slate-300">parseFloat + 検証</span>
                                                    <div class="flex items-center space-x-2">
                                                        <div class="w-16 bg-slate-600 h-2 rounded-full">
                                                            <div class="w-10 bg-yellow-500 h-2 rounded-full"></div>
                                                        </div>
                                                        <span class="text-sm text-yellow-400">普通</span>
                                                    </div>
                                                </div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-slate-300 font-medium">FSMアプローチ（本実装）</span>
                                                    <div class="flex items-center space-x-2">
                                                        <div class="w-16 bg-slate-600 h-2 rounded-full">
                                                            <div class="w-full bg-green-500 h-2 rounded-full"></div>
                                                        </div>
                                                        <span class="text-sm text-green-400">最速</span>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <div class="bg-purple-900 bg-opacity-30 rounded-lg p-6 border border-purple-500">
                                            <h4 class="font-semibold text-purple-200 mb-4">スケーラビリティ分析</h4>
                                            <div class="space-y-3 text-sm">
                                                <div class="flex justify-between">
                                                    <span class="text-purple-300">入力長 10文字:</span>
                                                    <span class="text-purple-200">~0.01ms</span>
                                                </div>
                                                <div class="flex justify-between">
                                                    <span class="text-purple-300">入力長 100文字:</span>
                                                    <span class="text-purple-200">~0.1ms</span>
                                                </div>
                                                <div class="flex justify-between">
                                                    <span class="text-purple-300">入力長 1000文字:</span>
                                                    <span class="text-purple-200">~1ms</span>
                                                </div>
                                                <div class="mt-4 pt-3 border-t border-purple-600">
                                                    <p class="text-xs text-purple-300 italic">
                                                        ※ 実際の制約では20文字まで
                                                    </p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <!-- Test Cases Section -->
                    <section id="tests" class="mb-16">
                        <div class="gradient-border hover-lift p-8">
                            <div class="section-header flex items-center justify-between mb-6 cursor-pointer" data-section="tests">
                                <h2 class="text-3xl font-bold bg-gradient-to-r from-emerald-400 to-teal-500 bg-clip-text text-transparent">
                                    テスト例とデモ
                                </h2>
                                <svg class="collapse-icon w-6 h-6 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </div>
                            <div class="section-content expanded">
                                <!-- Interactive Demo -->
                                <div class="mb-8">
                                    <h3 class="text-xl font-semibold text-slate-200 mb-4">インタラクティブデモ</h3>
                                    <div class="bg-slate-800 rounded-lg p-6 border border-slate-600">
                                        <div class="mb-4">
                                            <label class="block text-sm font-medium text-slate-300 mb-2" for="testInput">テスト文字列を入力:</label>
                                            <div class="flex space-x-4">
                                                <input id="testInput" type="text" placeholder="例: 123.45e-6" class="flex-1 px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder-slate-400 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none">
                                                <button id="testBtn" class="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-colors">
                                                    テスト実行
                                                </button>
                                            </div>
                                        </div>
                                        <div id="testResult" class="hidden p-4 rounded-lg border">
                                            <div class="flex items-center space-x-3 mb-3">
                                                <div id="resultIcon" class="w-8 h-8 rounded-full flex items-center justify-center">
                                                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                                    </svg>
                                                </div>
                                                <div>
                                                    <div id="resultText" class="font-semibold"></div>
                                                    <div id="resultDetail" class="text-sm"></div>
                                                </div>
                                            </div>
                                            <div id="stateTrace" class="mt-4 p-3 bg-slate-900 rounded border">
                                                <h5 class="text-sm font-medium text-slate-300 mb-2">状態遷移トレース:</h5>
                                                <div id="traceContent" class="code-font text-xs text-slate-400"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Test Cases Grid -->
                                <div class="grid md:grid-cols-2 gap-8">
                                    <!-- Valid Cases -->
                                    <div>
                                        <h3 class="text-xl font-semibold text-green-400 mb-4 flex items-center">
                                            <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                            </svg>
                                            有効な数値
                                        </h3>
                                        <div class="space-y-3" style="min-height: 420px;">
                                            <div class="test-case bg-green-900 bg-opacity-20 border border-green-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="4." onclick="handleTestCaseClick(this)" role="button" tabindex="0" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-green-300">"4."</code>
                                                    <span class="text-xs text-green-400 bg-green-900 px-2 py-1 rounded">小数</span>
                                                </div>
                                                <p class="text-xs text-green-200 mt-1">小数部なしの小数点付き</p>
                                            </div>
                                            <div class="test-case bg-green-900 bg-opacity-20 border border-green-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="123" onclick="handleTestCaseClick(this)" role="button" tabindex="0" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-green-300">"123"</code>
                                                    <span class="text-xs text-green-400 bg-green-900 px-2 py-1 rounded">整数</span>
                                                </div>
                                                <p class="text-xs text-green-200 mt-1">基本的な正の整数</p>
                                            </div>

                                            <div class="test-case bg-green-900 bg-opacity-20 border border-green-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="-123.45" onclick="handleTestCaseClick(this)" role="button" tabindex="0" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-green-300">"-123.45"</code>
                                                    <span class="text-xs text-green-400 bg-green-900 px-2 py-1 rounded">小数</span>
                                                </div>
                                                <p class="text-xs text-green-200 mt-1">負の小数値</p>
                                            </div>

                                            <div class="test-case bg-green-900 bg-opacity-20 border border-green-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="2e10" onclick="handleTestCaseClick(this)" role="button" tabindex="0" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-green-300">"2e10"</code>
                                                    <span class="text-xs text-green-400 bg-green-900 px-2 py-1 rounded">指数</span>
                                                </div>
                                                <p class="text-xs text-green-200 mt-1">科学記数法（小文字）</p>
                                            </div>

                                            <div class="test-case bg-green-900 bg-opacity-20 border border-green-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="+3.14E-2" onclick="handleTestCaseClick(this)" role="button" tabindex="0" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-green-300">"+3.14E-2"</code>
                                                    <span class="text-xs text-green-400 bg-green-900 px-2 py-1 rounded">複合</span>
                                                </div>
                                                <p class="text-xs text-green-200 mt-1">正符号付き小数の負指数</p>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Invalid Cases -->
                                    <div>
                                        <h3 class="text-xl font-semibold text-red-400 mb-4 flex items-center">
                                            <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                            </svg>
                                            無効な文字列
                                        </h3>
                                        <div class="space-y-3" style="min-height: 420px;">
                                            <div class="test-case bg-red-900 bg-opacity-20 border border-red-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="abc" onclick="handleTestCaseClick(this)" role="button" tabindex="0" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-red-300">"abc"</code>
                                                    <span class="text-xs text-red-400 bg-red-900 px-2 py-1 rounded">文字</span>
                                                </div>
                                                <p class="text-xs text-red-200 mt-1">アルファベット文字</p>
                                            </div>

                                            <div class="test-case bg-red-900 bg-opacity-20 border border-red-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="1e" onclick="handleTestCaseClick(this)" role="button" tabindex="0" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-red-300">"1e"</code>
                                                    <span class="text-xs text-red-400 bg-red-900 px-2 py-1 rounded">不完全</span>
                                                </div>
                                                <p class="text-xs text-red-200 mt-1">指数部が欠如</p>
                                            </div>

                                            <div class="test-case bg-red-900 bg-opacity-20 border border-red-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="--6" onclick="handleTestCaseClick(this)" role="button" tabindex="0" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-red-300">"--6"</code>
                                                    <span class="text-xs text-red-400 bg-red-900 px-2 py-1 rounded">二重符号</span>
                                                </div>
                                                <p class="text-xs text-red-200 mt-1">重複する負符号</p>
                                            </div>

                                            <div class="test-case bg-red-900 bg-opacity-20 border border-red-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="99e2.5" onclick="handleTestCaseClick(this)" role="button" tabindex="0" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-red-300">"99e2.5"</code>
                                                    <span class="text-xs text-red-400 bg-red-900 px-2 py-1 rounded">小数指数</span>
                                                </div>
                                                <p class="text-xs text-red-200 mt-1">指数部に小数点</p>
                                            </div>


                                            <div class="test-case bg-red-900 bg-opacity-20 border border-red-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="1a" onclick="handleTestCaseClick(this)" role="button" tabindex="0" onkeydown="handleTestCaseKeydown(event, this)" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-red-300">"1a"</code>
                                                    <span class="text-xs text-red-400 bg-red-900 px-2 py-1 rounded">混合</span>
                                                </div>
                                                <p class="text-xs text-red-200 mt-1">数字と文字の混合</p>
                                            </div>

                                            <div class="test-case bg-red-900 bg-opacity-20 border border-red-500 rounded-lg p-4 hover:bg-opacity-30 transition-colors cursor-pointer" data-input="." onclick="handleTestCaseClick(this)" role="button" tabindex="0" onkeydown="handleTestCaseKeydown(event, this)" style="min-height: 70px;">
                                                <div class="flex justify-between items-center">
                                                    <code class="code-font text-red-300">"."</code>
                                                    <span class="text-xs text-red-400 bg-red-900 px-2 py-1 rounded">単体</span>
                                                </div>
                                                <p class="text-xs text-red-200 mt-1">小数点のみ</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Performance Metrics -->
                                <div class="mt-8 bg-slate-800 rounded-lg p-6 border border-slate-600">
                                    <h3 class="text-xl font-semibold text-slate-200 mb-4">パフォーマンステスト結果</h3>
                                    <div class="grid md:grid-cols-3 gap-6">
                                        <div class="text-center">
                                            <div class="text-3xl font-bold text-blue-400 mb-2">100,000</div>
                                            <div class="text-sm text-slate-400">テスト実行回数</div>
                                        </div>
                                        <div class="text-center">
                                            <div class="text-3xl font-bold text-green-400 mb-2">~15ms</div>
                                            <div class="text-sm text-slate-400">平均実行時間</div>
                                        </div>
                                        <div class="text-center">
                                            <div class="text-3xl font-bold text-purple-400 mb-2">0MB</div>
                                            <div class="text-sm text-slate-400">追加メモリ使用量</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>
                </div>
            </main>
        </div>

        <!-- Footer -->
        <footer class="bg-slate-900 border-t border-slate-700 py-8">
            <div class="container mx-auto px-6">
                <div class="grid md:grid-cols-3 gap-8">
                    <div>
                        <h4 class="font-semibold text-slate-200 mb-4">アルゴリズムの特徴</h4>
                        <ul class="space-y-2 text-sm text-slate-400">
                            <li>• TypeScript型安全性</li>
                            <li>• 有限状態機械パターン</li>
                            <li>• 線形時間計算量</li>
                            <li>• 定数空間使用量</li>
                        </ul>
                    </div>
                    <div>
                        <h4 class="font-semibold text-slate-200 mb-4">実装技術</h4>
                        <ul class="space-y-2 text-sm text-slate-400">
                            <li>• Union型による状態管理</li>
                            <li>• 型ガード関数</li>
                            <li>• Exhaustive switch</li>
                            <li>• エラーハンドリング</li>
                        </ul>
                    </div>
                    <div>
                        <h4 class="font-semibold text-slate-200 mb-4">パフォーマンス</h4>
                        <ul class="space-y-2 text-sm text-slate-400">
                            <li>• V8エンジン最適化対応</li>
                            <li>• インライン化促進</li>
                            <li>• メモリ効率性</li>
                            <li>• スケーラビリティ</li>
                        </ul>
                    </div>
                </div>
                <div class="border-t border-slate-700 mt-8 pt-8 text-center text-sm text-slate-400">
                    <p>TypeScript有限状態機械による数値検証アルゴリズム - 高性能・型安全な実装</p>
                </div>
            </div>
        </footer>

        <script>
            /*
            ===== JavaScript完全実装 =====
            
            モジュール構成:
            1. UIController - UI操作とイベント管理
            2. AnimationController - ステップバイステップアニメーション
            3. FSMSimulator - 有限状態機械シミュレーター
            4. TestRunner - テスト実行エンジン
            5. Utils - ユーティリティ関数群
            
            最適化技術:
            - メモリ効率的なDOM操作
            - イベント委譲による効率的リスナー管理
            - テンプレートリテラルによるDOM生成
            - レスポンシブ設計対応
            - エラーハンドリング完全実装
            */

            // ユーティリティ関数群
            const Utils = {
                getElement(id, required = true) {
                    const element = document.getElementById(id);
                    if (!element && required) {
                        console.error(`Required element not found: ${id}`);
                        return null;
                    }
                    return element;
                },

                debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                }
            };

            // テストケースクリック処理関数
            function handleTestCaseClick(element) {
                try {
                    const input = element.getAttribute('data-input');
                    if (!input) {
                        console.warn('Test case missing data-input attribute');
                        return;
                    }

                    // 入力フィールドに値を設定
                    const testInput = Utils.getElement('testInput');
                    if (testInput) {
                        testInput.value = input;

                        // 視覚的フィードバック
                        element.style.transform = 'scale(0.98)';
                        setTimeout(() => {
                            element.style.transform = '';
                        }, 150);

                        // 自動テスト実行
                        setTimeout(() => {
                            const testBtn = Utils.getElement('testBtn');
                            if (testBtn) {
                                testBtn.click();
                            }
                        }, 200);
                    }
                } catch (error) {
                    console.error('Error handling test case click:', error);
                }
            }

            // キーボードアクセシビリティ対応
            function handleTestCaseKeydown(event, element) {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    handleTestCaseClick(element);
                }
            }


            // 有限状態機械シミュレーター
            const FSMSimulator = {
                State: {
                    INITIAL: 0,
                    SIGN: 1,
                    INTEGER: 2,
                    DOT: 3,
                    DECIMAL: 4,
                    EXP: 5,
                    EXP_SIGN: 6,
                    EXP_NUMBER: 7
                },

                stateNames: {
                    0: 'INITIAL',
                    1: 'SIGN',
                    2: 'INTEGER',
                    3: 'DOT',
                    4: 'DECIMAL',
                    5: 'EXP',
                    6: 'EXP_SIGN',
                    7: 'EXP_NUMBER'
                },

                isDigit(char) {
                    return char >= '0' && char <= '9';
                },

                isSign(char) {
                    return char === '+' || char === '-';
                },

                isExp(char) {
                    return char === 'e' || char === 'E';
                },

                isValidEndState(state) {
                    return state === this.State.INTEGER ||
                        state === this.State.DECIMAL ||
                        state === this.State.EXP_NUMBER;
                },

                getStateDescription(state, char, isValid) {
                    const descriptions = {
                        [this.State.INITIAL]: `初期状態から文字 '${char}' を処理中`,
                        [this.State.SIGN]: `符号 '${char}' を読み取り、次の文字を待機`,
                        [this.State.INTEGER]: `整数部 '${char}' を読み取り中`,
                        [this.State.DOT]: `小数点を読み取り、小数部を待機`,
                        [this.State.DECIMAL]: `小数部 '${char}' を読み取り中`,
                        [this.State.EXP]: `指数記号を読み取り、指数部を待機`,
                        [this.State.EXP_SIGN]: `指数符号を読み取り、指数値を待機`,
                        [this.State.EXP_NUMBER]: `指数部 '${char}' を読み取り中`
                    };

                    let desc = descriptions[state] || `状態 ${this.stateNames[state]} で文字 '${char}' を処理`;
                    if (isValid !== undefined) {
                        desc += isValid ? ' - 有効な遷移' : ' - 無効な遷移';
                    }
                    return desc;
                },

                validateNumber(s) {
                    if (typeof s !== 'string' || s.length === 0) {
                        return { valid: false, trace: [], error: 'Invalid input' };
                    }

                    let state = this.State.INITIAL;
                    let trace = [{
                        step: 0,
                        char: null,
                        prevState: null,
                        newState: this.stateNames[state],
                        description: '初期状態で開始',
                        valid: null
                    }];

                    for (let i = 0; i < s.length; i++) {
                        const char = s[i];
                        const prevState = state;
                        let isValidTransition = true;

                        switch (state) {
                            case this.State.INITIAL:
                                if (this.isSign(char)) {
                                    state = this.State.SIGN;
                                } else if (this.isDigit(char)) {
                                    state = this.State.INTEGER;
                                } else if (char === '.') {
                                    state = this.State.DOT;
                                } else {
                                    isValidTransition = false;
                                }
                                break;

                            case this.State.SIGN:
                                if (this.isDigit(char)) {
                                    state = this.State.INTEGER;
                                } else if (char === '.') {
                                    state = this.State.DOT;
                                } else {
                                    isValidTransition = false;
                                }
                                break;

                            case this.State.INTEGER:
                                if (this.isDigit(char)) {
                                    // 同一状態継続
                                } else if (char === '.') {
                                    state = this.State.DECIMAL;
                                } else if (this.isExp(char)) {
                                    state = this.State.EXP;
                                } else {
                                    isValidTransition = false;
                                }
                                break;

                            case this.State.DOT:
                                if (this.isDigit(char)) {
                                    state = this.State.DECIMAL;
                                } else {
                                    isValidTransition = false;
                                }
                                break;

                            case this.State.DECIMAL:
                                if (this.isDigit(char)) {
                                    // 同一状態継続
                                } else if (this.isExp(char)) {
                                    state = this.State.EXP;
                                } else {
                                    isValidTransition = false;
                                }
                                break;

                            case this.State.EXP:
                                if (this.isSign(char)) {
                                    state = this.State.EXP_SIGN;
                                } else if (this.isDigit(char)) {
                                    state = this.State.EXP_NUMBER;
                                } else {
                                    isValidTransition = false;
                                }
                                break;

                            case this.State.EXP_SIGN:
                                if (this.isDigit(char)) {
                                    state = this.State.EXP_NUMBER;
                                } else {
                                    isValidTransition = false;
                                }
                                break;

                            case this.State.EXP_NUMBER:
                                if (this.isDigit(char)) {
                                    // 同一状態継続
                                } else {
                                    isValidTransition = false;
                                }
                                break;
                        }

                        trace.push({
                            step: i + 1,
                            char: char,
                            charIndex: i,
                            prevState: this.stateNames[prevState],
                            newState: this.stateNames[state],
                            description: this.getStateDescription(state, char, isValidTransition),
                            valid: isValidTransition
                        });

                        if (!isValidTransition) {
                            return {
                                valid: false,
                                trace,
                                error: `Invalid character '${char}' at position ${i} in state ${this.stateNames[prevState]}`
                            };
                        }
                    }

                    const finalValid = this.isValidEndState(state);
                    trace.push({
                        step: s.length + 1,
                        char: null,
                        prevState: this.stateNames[state],
                        newState: this.stateNames[state],
                        description: `文字列終了: ${this.stateNames[state]} (${finalValid ? '有効' : '無効'}な終了状態)`,
                        valid: finalValid
                    });

                    return {
                        valid: finalValid,
                        trace,
                        finalState: this.stateNames[state],
                        error: finalValid ? null : `Invalid end state: ${this.stateNames[state]}`
                    };
                }
            };

            // ===== モジュール4: UIコントローラー =====
            const UIController = {
                init() {
                    this.bindEvents();
                    this.setupTestCases();
                },

                bindEvents() {
                    // 入力フィールドのイベント
                    const inputField = Utils.getElement('numberInput', false);
                    if (inputField) {
                        const debouncedValidate = Utils.debounce(() => {
                            this.validateInput();
                        }, 300);

                        inputField.addEventListener('input', debouncedValidate);
                        inputField.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                this.validateInput();
                            }
                        });
                    }

                    // テストボタンのイベント
                    const testBtn = Utils.getElement('testBtn', false);
                    if (testBtn) {
                        testBtn.addEventListener('click', () => this.validateInput());
                    }

                    // タブ切り替えのイベント
                    document.addEventListener('click', (e) => {
                        if (e.target.classList.contains('tab-button')) {
                            this.switchTab(e.target.dataset.tab);
                        }
                    });
                },

                setupTestCases() {
                    // テストケースのクリックイベント
                    document.addEventListener('click', (e) => {
                        const testCase = e.target.closest('.test-case');
                        if (testCase) {
                            const input = testCase.dataset.input;
                            const inputField = Utils.getElement('numberInput', false);
                            if (inputField && input) {
                                inputField.value = input;
                                this.validateInput();
                            }
                        }
                    });
                },


                validateInput() {
                    const inputField = Utils.getElement('numberInput', false);
                    if (!inputField) return;

                    const input = inputField.value.trim();

                    if (!input) {
                        this.clearResults();
                        return;
                    }

                    try {
                        // FSMシミュレーターで検証
                        const result = FSMSimulator.validateNumber(input);
                        this.displayValidationResult(result, input);

                        // アニメーション用のデータを準備
                        AnimationController.setTraceData(result.trace);

                    } catch (error) {
                        console.error('Validation error:', error);
                        this.showValidationError('検証中にエラーが発生しました');
                    }
                },

                displayValidationResult(result, input) {
                    const resultContainer = Utils.getElement('validationResult', false);
                    if (!resultContainer) return;

                    resultContainer.classList.remove('hidden');

                    // 結果の基本情報を表示
                    const isValid = result.valid;
                    const statusClass = isValid ? 'success' : 'error';
                    const statusIcon = isValid ? '✓' : '✗';
                    const statusText = isValid ? '有効な数値' : '無効な文字列';

                    resultContainer.innerHTML = `
                        <div class="result-header ${statusClass}">
                            <div class="result-icon">${statusIcon}</div>
                            <div class="result-info">
                                <h3>${statusText}</h3>
                                <p>入力: "${input}"</p>
                                <p>最終状態: ${result.finalState}</p>
                                ${result.error ? `<p class="error-message">${result.error}</p>` : ''}
                            </div>
                        </div>
                        
                        <div class="result-details">
                            <div class="trace-summary">
                                <h4>処理ステップ数: ${result.trace.length}</h4>
                                <p>実行時間: ${result.executionTime || 'N/A'}ms</p>
                            </div>
                            
                            <div class="state-transitions">
                                <h4>状態遷移の詳細</h4>
                                <div class="transition-list">
                                    ${this.generateTransitionList(result.trace)}
                                </div>
                            </div>
                        </div>
                        
                        <div class="result-actions">
                            <button onclick="AnimationController.play()" class="btn btn-primary">
                                アニメーション再生
                            </button>
                            <button onclick="this.copyResult('${input}', ${isValid})" class="btn btn-secondary">
                                結果をコピー
                            </button>
                        </div>
                    `;

                    // 結果をスムーズにスクロール表示
                    resultContainer.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                },

                generateTransitionList(trace) {
                    return trace.map((step, index) => {
                        const isValid = step.valid !== false;
                        const statusClass = isValid ? 'valid-step' : 'invalid-step';
                        const charDisplay = step.char ? `'${step.char}'` : '初期状態';

                        return `
                            <div class="transition-item ${statusClass}" data-step="${index}">
                                <div class="step-number">${step.step}</div>
                                <div class="step-content">
                                    <div class="step-char">${charDisplay}</div>
                                    <div class="step-transition">
                                        ${step.prevState || 'START'} → ${step.newState}
                                    </div>
                                    <div class="step-description">${step.description}</div>
                                </div>
                            </div>
                        `;
                    }).join('');
                },

                clearResults() {
                    const resultContainer = Utils.getElement('validationResult', false);
                    if (resultContainer) {
                        resultContainer.classList.add('hidden');
                        resultContainer.innerHTML = '';
                    }
                },

                showValidationError(message) {
                    const resultContainer = Utils.getElement('validationResult', false);
                    if (!resultContainer) return;

                    resultContainer.classList.remove('hidden');
                    resultContainer.innerHTML = `
                        <div class="result-header error">
                            <div class="result-icon">⚠</div>
                            <div class="result-info">
                                <h3>エラー</h3>
                                <p>${message}</p>
                            </div>
                        </div>
                    `;
                },

                switchTab(tabName) {
                    // すべてのタブボタンから active クラスを削除
                    document.querySelectorAll('.tab-button').forEach(btn => {
                        btn.classList.remove('active');
                    });

                    // すべてのタブコンテンツを非表示
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.add('hidden');
                    });

                    // 選択されたタブをアクティブに
                    const activeTabButton = document.querySelector(`[data-tab="${tabName}"]`);
                    const activeTabContent = Utils.getElement(`${tabName}Tab`, false);

                    if (activeTabButton) {
                        activeTabButton.classList.add('active');
                    }

                    if (activeTabContent) {
                        activeTabContent.classList.remove('hidden');

                        // タブ切り替え時の特別な処理
                        this.handleTabSwitch(tabName);
                    }
                },

                handleTabSwitch(tabName) {
                    switch (tabName) {
                        case 'simulator':
                            // シミュレータータブ: 入力フィールドにフォーカス
                            const inputField = Utils.getElement('numberInput', false);
                            if (inputField) {
                                setTimeout(() => inputField.focus(), 100);
                            }
                            break;

                        case 'animation':
                            // アニメーションタブ: コントロールパネルを更新
                            AnimationController.updateControlButtons();
                            break;

                        case 'examples':
                            // 例題タブ: 特別な処理なし
                            break;

                        case 'theory':
                            // 理論タブ: 数式のレンダリング（MathJax等があれば）
                            if (window.MathJax && window.MathJax.typesetPromise) {
                                window.MathJax.typesetPromise();
                            }
                            break;
                    }
                },

                copyResult(input, isValid) {
                    const resultText = `入力: "${input}"\n結果: ${isValid ? '有効' : '無効'}`;

                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(resultText).then(() => {
                            this.showCopyFeedback('結果をコピーしました');
                        }).catch(() => {
                            this.fallbackCopy(resultText);
                        });
                    } else {
                        this.fallbackCopy(resultText);
                    }
                },

                fallbackCopy(text) {
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();

                    try {
                        document.execCommand('copy');
                        this.showCopyFeedback('結果をコピーしました');
                    } catch (err) {
                        this.showCopyFeedback('コピーに失敗しました');
                    }

                    document.body.removeChild(textArea);
                },

                showCopyFeedback(message) {
                    const feedback = document.createElement('div');
                    feedback.className = 'copy-feedback';
                    feedback.textContent = message;
                    feedback.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #10b981;
                        color: white;
                        padding: 12px 20px;
                        border-radius: 8px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                        z-index: 1000;
                        font-size: 14px;
                        font-weight: 500;
                        transform: translateX(100%);
                        transition: transform 0.3s ease;
                    `;

                    document.body.appendChild(feedback);

                    // アニメーション表示
                    setTimeout(() => {
                        feedback.style.transform = 'translateX(0)';
                    }, 10);

                    // 3秒後に削除
                    setTimeout(() => {
                        feedback.style.transform = 'translateX(100%)';
                        setTimeout(() => {
                            if (feedback.parentNode) {
                                feedback.parentNode.removeChild(feedback);
                            }
                        }, 300);
                    }, 3000);
                },

                // レスポンシブ対応のためのメソッド
                handleResize() {
                    const isMobile = window.innerWidth < 768;

                    // モバイル表示時の調整
                    if (isMobile) {
                        this.optimizeForMobile();
                    } else {
                        this.optimizeForDesktop();
                    }
                },

                optimizeForMobile() {
                    // モバイル用の最適化
                    const resultContainer = Utils.getElement('validationResult', false);
                    if (resultContainer) {
                        resultContainer.classList.add('mobile-optimized');
                    }

                    // タブの表示を調整
                    document.querySelectorAll('.tab-button').forEach(btn => {
                        btn.classList.add('mobile-tab');
                    });
                },

                optimizeForDesktop() {
                    // デスクトップ用の最適化
                    const resultContainer = Utils.getElement('validationResult', false);
                    if (resultContainer) {
                        resultContainer.classList.remove('mobile-optimized');
                    }

                    // タブの表示を調整
                    document.querySelectorAll('.tab-button').forEach(btn => {
                        btn.classList.remove('mobile-tab');
                    });
                },

                // アクセシビリティ対応
                setupAccessibility() {
                    // キーボードナビゲーション
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Tab') {
                            document.body.classList.add('keyboard-navigation');
                        }
                    });

                    document.addEventListener('mousedown', () => {
                        document.body.classList.remove('keyboard-navigation');
                    });


                },

                updateAriaAttributes() {
                    // タブボタンにARIA属性を設定
                    document.querySelectorAll('.tab-button').forEach((btn, index) => {
                        const tabName = btn.getAttribute('data-tab');
                        btn.setAttribute('role', 'tab');
                        btn.setAttribute('aria-controls', `${tabName}Tab`);
                        btn.setAttribute('aria-selected', btn.classList.contains('active') ? 'true' : 'false');
                        btn.setAttribute('tabindex', btn.classList.contains('active') ? '0' : '-1');
                    });

                    // タブパネルにARIA属性を設定
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.setAttribute('role', 'tabpanel');
                        content.setAttribute('tabindex', '0');
                    });

                    // 入力フィールドにラベルを関連付け
                    const inputField = Utils.getElement('numberInput', false);
                    if (inputField) {
                        inputField.setAttribute('aria-describedby', 'inputHelp');
                        inputField.setAttribute('aria-label', '検証する数値文字列を入力');
                    }

                    // 結果表示エリアにライブリージョンを設定
                    const resultContainer = Utils.getElement('validationResult', false);
                    if (resultContainer) {
                        resultContainer.setAttribute('aria-live', 'polite');
                        resultContainer.setAttribute('aria-atomic', 'true');
                    }
                },

                // エラーハンドリング
                handleError(error, context = 'UIController') {
                    console.error(`${context} Error:`, error);

                    // ユーザーフレンドリーなエラーメッセージを表示
                    this.showErrorNotification('申し訳ございません。エラーが発生しました。ページを再読み込みしてお試しください。');
                },

                showErrorNotification(message) {
                    const notification = document.createElement('div');
                    notification.className = 'error-notification';
                    notification.innerHTML = `
                        <div class="notification-content">
                            <div class="notification-icon">⚠️</div>
                            <div class="notification-message">${message}</div>
                            <button class="notification-close" aria-label="通知を閉じる">×</button>
                        </div>
                    `;

                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #fee2e2;
                        border: 1px solid #fecaca;
                        color: #991b1b;
                        padding: 16px;
                        border-radius: 8px;
                        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
                        z-index: 1000;
                        max-width: 400px;
                        transform: translateX(100%);
                        transition: transform 0.3s ease;
                    `;

                    document.body.appendChild(notification);

                    // アニメーション表示
                    setTimeout(() => {
                        notification.style.transform = 'translateX(0)';
                    }, 10);

                    // 閉じるボタンのイベント
                    const closeBtn = notification.querySelector('.notification-close');
                    closeBtn.addEventListener('click', () => {
                        this.removeNotification(notification);
                    });

                    // 5秒後に自動削除
                    setTimeout(() => {
                        this.removeNotification(notification);
                    }, 5000);
                },

                removeNotification(notification) {
                    if (notification && notification.parentNode) {
                        notification.style.transform = 'translateX(100%)';
                        setTimeout(() => {
                            if (notification.parentNode) {
                                notification.parentNode.removeChild(notification);
                            }
                        }, 300);
                    }
                }
            };


            // ===== モジュール3: Visualizer =====
            const Visualizer = {
                currentState: 'start',
                transitionHistory: [],
                animationSpeed: 500,

                init() {
                    this.setupVisualizationElements();
                    this.setupStateDisplay();
                    this.setupTransitionAnimation();

                    console.log('Visualizer initialized successfully');
                },

                setupVisualizationElements() {
                    // 状態表示エリアの初期化
                    const stateDisplay = document.getElementById('state-display');
                    if (stateDisplay) {
                        stateDisplay.innerHTML = `
                            <div class="current-state">
                                <span class="state-label">現在の状態:</span>
                                <span class="state-value" id="current-state-value">start</span>
                            </div>
                            <div class="transition-log" id="transition-log">
                                <h4>状態遷移ログ</h4>
                                <ul id="transition-list"></ul>
                            </div>
                        `;
                    }
                },

                setupStateDisplay() {
                    // 状態表示の設定
                    const style = document.createElement('style');
                    style.textContent = `
                        .current-state {
                            padding: 15px;
                            background: #f0f4f8;
                            border-radius: 8px;
                            margin-bottom: 20px;
                            border-left: 4px solid #667eea;
                        }
                        
                        .state-label {
                            font-weight: bold;
                            color: #4a5568;
                        }
                        
                        .state-value {
                            color: #667eea;
                            font-family: monospace;
                            font-size: 1.1em;
                            margin-left: 10px;
                            padding: 4px 8px;
                            background: white;
                            border-radius: 4px;
                            border: 1px solid #e2e8f0;
                        }
                        
                        .transition-log {
                            background: #f7fafc;
                            border-radius: 8px;
                            padding: 15px;
                        }
                        
                        .transition-log h4 {
                            margin-bottom: 10px;
                            color: #2d3748;
                        }
                        
                        .transition-item {
                            padding: 8px 12px;
                            margin: 5px 0;
                            background: white;
                            border-radius: 4px;
                            border-left: 3px solid #38a169;
                            font-family: monospace;
                            font-size: 0.9em;
                        }
                        
                        .transition-item.invalid {
                            border-left-color: #e53e3e;
                            background: #fed7d7;
                        }
                        
                        .transition-char {
                            font-weight: bold;
                            color: #2b6cb0;
                        }
                        
                        .transition-arrow {
                            color: #718096;
                            margin: 0 8px;
                        }
                    `;
                    document.head.appendChild(style);
                },

                setupTransitionAnimation() {
                    // アニメーション設定
                    this.animationQueue = [];
                    this.isAnimating = false;
                },

                updateStateDisplay(state, char, isValid) {
                    // 現在の状態表示を更新
                    const stateValueElement = document.getElementById('current-state-value');
                    if (stateValueElement) {
                        stateValueElement.textContent = state;
                        stateValueElement.className = `state-value ${isValid ? 'valid' : 'invalid'}`;
                    }

                    // 遷移ログに追加
                    this.addTransitionToLog(this.currentState, state, char, isValid);
                    this.currentState = state;
                },

                addTransitionToLog(fromState, toState, char, isValid) {
                    const transitionList = document.getElementById('transition-list');
                    if (transitionList) {
                        const listItem = document.createElement('li');
                        listItem.className = `transition-item ${isValid ? 'valid' : 'invalid'}`;

                        const charDisplay = char === ' ' ? 'SPACE' : char || 'EOF';
                        listItem.innerHTML = `
                            <span class="transition-state">${fromState}</span>
                            <span class="transition-arrow">→</span>
                            <span class="transition-char">'${charDisplay}'</span>
                            <span class="transition-arrow">→</span>
                            <span class="transition-state">${toState}</span>
                            ${!isValid ? ' <span style="color: #e53e3e;">(無効)</span>' : ''}
                        `;

                        transitionList.appendChild(listItem);

                        // 最新の遷移を表示するためにスクロール
                        listItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                        // 遷移履歴に追加
                        this.transitionHistory.push({
                            from: fromState,
                            to: toState,
                            char: char,
                            isValid: isValid,
                            timestamp: Date.now()
                        });
                    }
                },

                highlightTransition(fromState, toState) {
                    // 状態遷移のハイライト表示
                    const stateElements = document.querySelectorAll('.state-node');
                    stateElements.forEach(element => {
                        element.classList.remove('highlighted');
                        if (element.dataset.state === toState) {
                            element.classList.add('highlighted');

                            // アニメーション効果
                            element.style.transform = 'scale(1.1)';
                            setTimeout(() => {
                                element.style.transform = 'scale(1)';
                            }, this.animationSpeed);
                        }
                    });
                },

                showResult(isValid, finalState) {
                    // 最終結果の表示
                    const resultDisplay = document.getElementById('validation-result');
                    if (resultDisplay) {
                        resultDisplay.innerHTML = `
                            <div class="result-container ${isValid ? 'valid' : 'invalid'}">
                                <div class="result-icon">
                                    ${isValid ? '✅' : '❌'}
                                </div>
                                <div class="result-text">
                                    <strong>${isValid ? '有効な数値' : '無効な数値'}</strong>
                                    <br>
                                    <small>最終状態: ${finalState}</small>
                                </div>
                            </div>
                        `;

                        // 結果表示のアニメーション
                        resultDisplay.style.opacity = '0';
                        resultDisplay.style.transform = 'translateY(20px)';

                        setTimeout(() => {
                            resultDisplay.style.transition = 'all 0.3s ease';
                            resultDisplay.style.opacity = '1';
                            resultDisplay.style.transform = 'translateY(0)';
                        }, 100);
                    }
                },

                clearVisualization() {
                    // 表示をクリア
                    this.currentState = 'start';
                    this.transitionHistory = [];

                    const stateValueElement = document.getElementById('current-state-value');
                    if (stateValueElement) {
                        stateValueElement.textContent = 'start';
                        stateValueElement.className = 'state-value';
                    }

                    const transitionList = document.getElementById('transition-list');
                    if (transitionList) {
                        transitionList.innerHTML = '';
                    }

                    const resultDisplay = document.getElementById('validation-result');
                    if (resultDisplay) {
                        resultDisplay.innerHTML = '';
                    }
                },

                exportVisualizationData() {
                    // 視覚化データのエクスポート
                    return {
                        transitionHistory: this.transitionHistory,
                        currentState: this.currentState,
                        timestamp: new Date().toISOString()
                    };
                },

                cleanup() {
                    // クリーンアップ
                    this.clearVisualization();
                    this.animationQueue = [];
                    this.isAnimating = false;

                    console.log('Visualizer cleaned up');
                }
            };

            // ===== モジュール5: アニメーションコントローラー =====
            const AnimationController = {
                traceData: [],
                currentStep: 0,
                isPlaying: false,
                animationSpeed: 1000,
                animationInterval: null,

                init() {
                    this.bindEvents();
                    this.setupSpeedControl();
                    console.log('AnimationController initialized successfully');
                },

                bindEvents() {
                    const playBtn = Utils.getElement('playBtn', false);
                    const pauseBtn = Utils.getElement('pauseBtn', false);
                    const resetBtn = Utils.getElement('resetBtn', false);
                    const stepBtn = Utils.getElement('stepBtn', false);

                    if (playBtn) {
                        playBtn.addEventListener('click', () => this.play());
                    }
                    if (pauseBtn) {
                        pauseBtn.addEventListener('click', () => this.pause());
                    }
                    if (resetBtn) {
                        resetBtn.addEventListener('click', () => this.reset());
                    }
                    if (stepBtn) {
                        stepBtn.addEventListener('click', () => this.step());
                    }
                },

                setupSpeedControl() {
                    const speedControl = Utils.getElement('speedControl', false);
                    if (speedControl) {
                        speedControl.addEventListener('change', (e) => {
                            this.animationSpeed = parseInt(e.target.value);
                            if (this.isPlaying) {
                                this.pause();
                                this.play();
                            }
                        });
                    }
                },

                setTraceData(trace) {
                    this.traceData = trace || [];
                    this.currentStep = 0;
                    this.updateDisplay();
                    this.updateControlButtons();
                },

                play() {
                    if (this.isPlaying || this.traceData.length === 0) return;

                    this.isPlaying = true;
                    this.updateControlButtons();

                    this.animationInterval = setInterval(() => {
                        if (this.currentStep < this.traceData.length - 1) {
                            this.currentStep++;
                            this.updateDisplay();
                        } else {
                            this.pause();
                        }
                    }, this.animationSpeed);
                },

                pause() {
                    this.isPlaying = false;
                    if (this.animationInterval) {
                        clearInterval(this.animationInterval);
                        this.animationInterval = null;
                    }
                    this.updateControlButtons();
                },

                reset() {
                    this.pause();
                    this.currentStep = 0;
                    this.updateDisplay();
                    this.updateControlButtons();
                },

                step() {
                    if (this.currentStep < this.traceData.length - 1) {
                        this.currentStep++;
                        this.updateDisplay();
                        this.updateControlButtons();
                    }
                },

                updateDisplay() {
                    if (this.traceData.length === 0) return;

                    const currentTrace = this.traceData[this.currentStep];

                    // ステップ情報を更新
                    const stepInfo = Utils.getElement('stepInfo', false);
                    if (stepInfo) {
                        stepInfo.textContent = `ステップ ${this.currentStep + 1} / ${this.traceData.length}`;
                    }

                    // 現在の状態を更新
                    const currentState = Utils.getElement('currentState', false);
                    if (currentState) {
                        currentState.textContent = currentTrace.state;
                        currentState.className = `state-display ${this.getStateClass(currentTrace.state)}`;
                    }

                    // 入力文字を更新
                    const currentChar = Utils.getElement('currentChar', false);
                    if (currentChar) {
                        currentChar.textContent = currentTrace.char || 'EOF';
                    }

                    // 説明を更新
                    const stepDescription = Utils.getElement('stepDescription', false);
                    if (stepDescription) {
                        stepDescription.textContent = currentTrace.description;
                    }

                    // 進行状況バーを更新
                    const progressBar = Utils.getElement('progressBar', false);
                    if (progressBar) {
                        const progress = ((this.currentStep + 1) / this.traceData.length) * 100;
                        progressBar.style.width = `${progress}%`;
                    }

                    // トレース履歴を更新
                    this.updateTraceHistory();
                },

                updateTraceHistory() {
                    const traceHistory = Utils.getElement('traceHistory', false);
                    if (!traceHistory) return;

                    const historyHTML = this.traceData.map((trace, index) => {
                        const isActive = index === this.currentStep;
                        const isPast = index < this.currentStep;
                        const statusClass = isActive ? 'active' : (isPast ? 'completed' : 'pending');

                        return `
                            <div class="trace-step ${statusClass}" data-step="${index}">
                                <div class="step-number">${index + 1}</div>
                                <div class="step-content">
                                    <div class="step-state">${trace.state}</div>
                                    <div class="step-char">'${trace.char || 'EOF'}'</div>
                                    <div class="step-desc">${trace.description}</div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    traceHistory.innerHTML = historyHTML;

                    // 現在のステップをスクロール表示
                    const activeStep = traceHistory.querySelector('.trace-step.active');
                    if (activeStep) {
                        activeStep.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                    }
                },

                getStateClass(state) {
                    const stateClasses = {
                        'start': 'state-start',
                        'sign': 'state-sign',
                        'integer': 'state-integer',
                        'decimal': 'state-decimal',
                        'fraction': 'state-fraction',
                        'exponent': 'state-exponent',
                        'exp_sign': 'state-exp-sign',
                        'exp_number': 'state-exp-number',
                        'end': 'state-end',
                        'error': 'state-error'
                    };
                    return stateClasses[state] || 'state-default';
                },

                updateControlButtons() {
                    const playBtn = Utils.getElement('playBtn', false);
                    const pauseBtn = Utils.getElement('pauseBtn', false);
                    const resetBtn = Utils.getElement('resetBtn', false);
                    const stepBtn = Utils.getElement('stepBtn', false);

                    const hasData = this.traceData.length > 0;
                    const canPlay = hasData && !this.isPlaying && this.currentStep < this.traceData.length - 1;
                    const canPause = this.isPlaying;
                    const canReset = hasData && this.currentStep > 0;
                    const canStep = hasData && !this.isPlaying && this.currentStep < this.traceData.length - 1;

                    if (playBtn) {
                        playBtn.disabled = !canPlay;
                        playBtn.style.display = this.isPlaying ? 'none' : 'inline-flex';
                        playBtn.setAttribute('aria-label', canPlay ? 'アニメーションを再生' : 'アニメーション再生不可');
                    }

                    if (pauseBtn) {
                        pauseBtn.disabled = !canPause;
                        pauseBtn.style.display = this.isPlaying ? 'inline-flex' : 'none';
                        pauseBtn.setAttribute('aria-label', canPause ? 'アニメーションを一時停止' : 'アニメーション一時停止不可');
                    }

                    if (resetBtn) {
                        resetBtn.disabled = !canReset;
                        resetBtn.setAttribute('aria-label', canReset ? 'アニメーションをリセット' : 'アニメーションリセット不可');
                    }

                    if (stepBtn) {
                        stepBtn.disabled = !canStep;
                        stepBtn.setAttribute('aria-label', canStep ? '次のステップに進む' : '次のステップなし');
                    }
                },

                // キーボードショートカット
                setupKeyboardShortcuts() {
                    document.addEventListener('keydown', (e) => {
                        // Ctrl/Cmd + キーの組み合わせのみ処理
                        if (!e.ctrlKey && !e.metaKey) return;

                        switch (e.key.toLowerCase()) {
                            case ' ': // スペースキー
                                e.preventDefault();
                                if (this.isPlaying) {
                                    this.pause();
                                } else {
                                    this.play();
                                }
                                break;
                            case 'r': // Rキー
                                e.preventDefault();
                                this.reset();
                                break;
                            case 'arrowright': // 右矢印キー
                                e.preventDefault();
                                this.step();
                                break;
                            case 'arrowleft': // 左矢印キー
                                e.preventDefault();
                                if (this.currentStep > 0) {
                                    this.currentStep--;
                                    this.updateDisplay();
                                    this.updateControlButtons();
                                }
                                break;
                        }
                    });
                },

                // アニメーション状態の保存と復元
                saveState() {
                    return {
                        currentStep: this.currentStep,
                        isPlaying: this.isPlaying,
                        animationSpeed: this.animationSpeed
                    };
                },

                restoreState(state) {
                    if (state) {
                        this.currentStep = state.currentStep || 0;
                        this.animationSpeed = state.animationSpeed || 1000;

                        if (state.isPlaying && this.traceData.length > 0) {
                            this.play();
                        }

                        this.updateDisplay();
                        this.updateControlButtons();
                    }
                }
            };

            // ===== モジュール7: アクセシビリティ強化 =====
            const AccessibilityEnhancer = {
                init() {
                    this.setupKeyboardNavigation();
                    this.setupScreenReaderSupport();
                    this.setupFocusManagement();
                    this.setupColorContrastCheck();
                    console.log('AccessibilityEnhancer initialized successfully');
                },

                setupKeyboardNavigation() {
                    // タブキーナビゲーション
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Tab') {
                            document.body.classList.add('keyboard-navigation');
                        }
                    });

                    // マウスクリック時はキーボードナビゲーションを無効化
                    document.addEventListener('mousedown', () => {
                        document.body.classList.remove('keyboard-navigation');
                    });

                    // カスタムキーボードショートカット
                    this.setupCustomShortcuts();
                },

                setupCustomShortcuts() {
                    const shortcuts = {
                        'Alt+1': () => this.focusElement('numberInput'),
                        'Alt+2': () => this.focusElement('testBtn'),
                        'Alt+3': () => this.focusElement('playBtn'),
                        'Alt+h': () => this.showShortcutHelp(),
                        'Escape': () => this.closeModals()
                    };

                    document.addEventListener('keydown', (e) => {
                        const key = this.getShortcutKey(e);
                        if (shortcuts[key]) {
                            e.preventDefault();
                            shortcuts[key]();
                        }
                    });
                },

                getShortcutKey(e) {
                    const parts = [];
                    if (e.ctrlKey) parts.push('Ctrl');
                    if (e.metaKey) parts.push('Cmd');
                    if (e.altKey) parts.push('Alt');
                    if (e.shiftKey) parts.push('Shift');

                    const key = e.key === ' ' ? 'Space' : e.key;
                    parts.push(key);

                    return parts.join('+');
                },

                focusElement(elementId) {
                    const element = Utils.getElement(elementId, false);
                    if (element) {
                        element.focus();
                        element.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                    }
                },

                showShortcutHelp() {
                    const helpModal = Utils.getElement('shortcutHelpModal', false);
                    if (helpModal) {
                        helpModal.classList.remove('hidden');
                        helpModal.setAttribute('aria-hidden', 'false');

                        // フォーカストラップ
                        const focusableElements = helpModal.querySelectorAll(
                            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                        );
                        if (focusableElements.length > 0) {
                            focusableElements[0].focus();
                        }
                    }
                },

                closeModals() {
                    const modals = document.querySelectorAll('.modal, [role="dialog"]');
                    modals.forEach(modal => {
                        modal.classList.add('hidden');
                        modal.setAttribute('aria-hidden', 'true');
                    });
                },

                setupScreenReaderSupport() {
                    // ライブリージョンの設定
                    this.createLiveRegion();

                    // 動的コンテンツの変更を通知
                    this.setupContentChangeAnnouncements();

                    // ARIAラベルの動的更新
                    this.setupDynamicAriaLabels();
                },

                createLiveRegion() {
                    const liveRegion = document.createElement('div');
                    liveRegion.id = 'liveRegion';
                    liveRegion.setAttribute('aria-live', 'polite');
                    liveRegion.setAttribute('aria-atomic', 'true');
                    liveRegion.className = 'sr-only';
                    liveRegion.style.cssText = `
                        position: absolute;
                        left: -10000px;
                        width: 1px;
                        height: 1px;
                        overflow: hidden;
                    `;
                    document.body.appendChild(liveRegion);
                },

                announceToScreenReader(message, priority = 'polite') {
                    const liveRegion = document.getElementById('liveRegion');
                    if (liveRegion) {
                        liveRegion.setAttribute('aria-live', priority);
                        liveRegion.textContent = message;

                        // 短時間後にクリア
                        setTimeout(() => {
                            liveRegion.textContent = '';
                        }, 1000);
                    }
                },

                setupContentChangeAnnouncements() {
                    // アニメーション状態変更の通知
                    const originalPlay = AnimationController.play;
                    AnimationController.play = function () {
                        originalPlay.call(this);
                        AccessibilityEnhancer.announceToScreenReader('アニメーションを開始しました');
                    };

                    const originalPause = AnimationController.pause;
                    AnimationController.pause = function () {
                        originalPause.call(this);
                        AccessibilityEnhancer.announceToScreenReader('アニメーションを一時停止しました');
                    };

                    const originalReset = AnimationController.reset;
                    AnimationController.reset = function () {
                        originalReset.call(this);
                        AccessibilityEnhancer.announceToScreenReader('アニメーションをリセットしました');
                    };
                },

                setupDynamicAriaLabels() {
                    // プログレスバーのARIA属性更新
                    const progressObserver = new MutationObserver((mutations) => {
                        mutations.forEach(mutation => {
                            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                                const progressBar = mutation.target;
                                if (progressBar.classList.contains('progress-fill')) {
                                    const width = progressBar.style.width;
                                    const percentage = parseInt(width) || 0;
                                    progressBar.setAttribute('aria-valuenow', percentage);
                                    progressBar.setAttribute('aria-valuetext', `${percentage}%完了`);
                                }
                            }
                        });
                    });

                    const progressBars = document.querySelectorAll('.progress-fill');
                    progressBars.forEach(bar => {
                        bar.setAttribute('role', 'progressbar');
                        bar.setAttribute('aria-valuemin', '0');
                        bar.setAttribute('aria-valuemax', '100');
                        progressObserver.observe(bar, { attributes: true });
                    });
                },

                setupFocusManagement() {
                    // フォーカストラップ
                    this.setupFocusTrap();

                    // フォーカス可視化
                    this.setupFocusVisualization();

                    // スキップリンク
                    this.setupSkipLinks();
                },

                setupFocusTrap() {
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Tab') {
                            const modal = document.querySelector('.modal:not(.hidden)');
                            if (modal) {
                                this.trapFocus(e, modal);
                            }
                        }
                    });
                },

                trapFocus(e, container) {
                    const focusableElements = container.querySelectorAll(
                        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                    );

                    if (focusableElements.length === 0) return;

                    const firstElement = focusableElements[0];
                    const lastElement = focusableElements[focusableElements.length - 1];

                    if (e.shiftKey) {
                        if (document.activeElement === firstElement) {
                            e.preventDefault();
                            lastElement.focus();
                        }
                    } else {
                        if (document.activeElement === lastElement) {
                            e.preventDefault();
                            firstElement.focus();
                        }
                    }
                },

                setupFocusVisualization() {
                    // カスタムフォーカススタイル
                    const style = document.createElement('style');
                    style.textContent = `
                        .keyboard-navigation *:focus {
                            outline: 2px solid #4F46E5 !important;
                            outline-offset: 2px !important;
                            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.1) !important;
                        }
                        
                        .keyboard-navigation button:focus,
                        .keyboard-navigation input:focus,
                        .keyboard-navigation select:focus,
                        .keyboard-navigation textarea:focus {
                            outline: 2px solid #4F46E5 !important;
                            outline-offset: 2px !important;
                        }
                    `;
                    document.head.appendChild(style);
                },

                setupSkipLinks() {
                    const skipLink = document.createElement('a');
                    skipLink.href = '#main-content';
                    skipLink.textContent = 'メインコンテンツにスキップ';
                    skipLink.className = 'skip-link';
                    skipLink.style.cssText = `
                        position: absolute;
                        top: -40px;
                        left: 6px;
                        background: #000;
                        color: #fff;
                        padding: 8px;
                        text-decoration: none;
                        border-radius: 4px;
                        z-index: 1000;
                        transition: top 0.3s;
                    `;

                    skipLink.addEventListener('focus', () => {
                        skipLink.style.top = '6px';
                    });

                    skipLink.addEventListener('blur', () => {
                        skipLink.style.top = '-40px';
                    });

                    document.body.insertBefore(skipLink, document.body.firstChild);
                },

                setupColorContrastCheck() {
                    // 色覚サポート設定
                    this.addColorBlindnessSupport();

                    // ハイコントラストモード
                    this.addHighContrastMode();
                },

                addColorBlindnessSupport() {
                    const colorModeSelect = document.createElement('select');
                    colorModeSelect.id = 'colorModeSelect';
                    colorModeSelect.setAttribute('aria-label', '色覚サポートモード選択');

                    const options = [
                        { value: 'normal', text: '通常' },
                        { value: 'protanopia', text: '1型色覚（赤）' },
                        { value: 'deuteranopia', text: '2型色覚（緑）' },
                        { value: 'tritanopia', text: '3型色覚（青）' }
                    ];

                    options.forEach(option => {
                        const optionElement = document.createElement('option');
                        optionElement.value = option.value;
                        optionElement.textContent = option.text;
                        colorModeSelect.appendChild(optionElement);
                    });

                    colorModeSelect.addEventListener('change', (e) => {
                        this.applyColorBlindnessFilter(e.target.value);
                    });

                    // 設定パネルに追加
                    const settingsPanel = Utils.getElement('settingsPanel', false);
                    if (settingsPanel) {
                        const label = document.createElement('label');
                        label.textContent = '色覚サポート: ';
                        label.appendChild(colorModeSelect);
                        settingsPanel.appendChild(label);
                    }
                },

                applyColorBlindnessFilter(mode) {
                    const filters = {
                        normal: 'none',
                        protanopia: 'url(#protanopia-filter)',
                        deuteranopia: 'url(#deuteranopia-filter)',
                        tritanopia: 'url(#tritanopia-filter)'
                    };

                    document.documentElement.style.filter = filters[mode] || 'none';

                    // SVGフィルターを動的に作成
                    if (mode !== 'normal' && !document.getElementById(`${mode}-filter`)) {
                        this.createColorBlindnessFilter(mode);
                    }
                },



                createColorBlindnessFilter(type) {
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.style.cssText = 'position: absolute; width: 0; height: 0;';

                    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                    filter.id = `${type}-filter`;

                    const feColorMatrix = document.createElementNS('http://www.w3.org/2000/svg', 'feColorMatrix');
                    feColorMatrix.setAttribute('type', 'matrix');

                    // 色覚タイプ別の変換行列
                    const matrices = {
                        protanopia: '0.567,0.433,0,0,0 0.558,0.442,0,0,0 0,0.242,0.758,0,0 0,0,0,1,0',
                        deuteranopia: '0.625,0.375,0,0,0 0.7,0.3,0,0,0 0,0.3,0.7,0,0 0,0,0,1,0',
                        tritanopia: '0.95,0.05,0,0,0 0,0.433,0.567,0,0 0,0.475,0.525,0,0 0,0,0,1,0'
                    };

                    feColorMatrix.setAttribute('values', matrices[type] || matrices.protanopia);

                    filter.appendChild(feColorMatrix);
                    defs.appendChild(filter);
                    svg.appendChild(defs);
                    document.body.appendChild(svg);
                },

                addHighContrastMode() {
                    const contrastToggle = document.createElement('button');
                    contrastToggle.id = 'contrastToggle';
                    contrastToggle.textContent = 'ハイコントラスト';
                    contrastToggle.setAttribute('aria-label', 'ハイコントラストモード切り替え');
                    contrastToggle.className = 'contrast-toggle-btn';

                    contrastToggle.addEventListener('click', () => {
                        document.body.classList.toggle('high-contrast');
                        const isHighContrast = document.body.classList.contains('high-contrast');
                        contrastToggle.textContent = isHighContrast ? '通常コントラスト' : 'ハイコントラスト';
                        this.announceToScreenReader(
                            isHighContrast ? 'ハイコントラストモードを有効にしました' : 'ハイコントラストモードを無効にしました'
                        );
                    });

                    // 設定パネルに追加
                    const settingsPanel = Utils.getElement('settingsPanel', false);
                    if (settingsPanel) {
                        settingsPanel.appendChild(contrastToggle);
                    }

                    // ハイコントラストスタイル
                    const contrastStyle = document.createElement('style');
                    contrastStyle.textContent = `
                        .high-contrast {
                            filter: contrast(150%) brightness(120%);
                        }
                        
                        .high-contrast .bg-gray-800 {
                            background-color: #000000 !important;
                        }
                        
                        .high-contrast .text-gray-300 {
                            color: #ffffff !important;
                        }
                        
                        .high-contrast .border-gray-700 {
                            border-color: #ffffff !important;
                        }
                        
                        .high-contrast button {
                            border: 2px solid #ffffff !important;
                        }
                        
                        .contrast-toggle-btn {
                            background: #4F46E5;
                            color: white;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 4px;
                            cursor: pointer;
                            margin: 10px 0;
                        }
                        
                        .contrast-toggle-btn:hover {
                            background: #3730A3;
                        }
                    `;
                    document.head.appendChild(contrastStyle);
                },

                setupReducedMotion() {
                    // ユーザーの動きの設定を確認
                    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');

                    const handleReducedMotion = (mediaQuery) => {
                        if (mediaQuery.matches) {
                            document.body.classList.add('reduced-motion');
                            this.announceToScreenReader('アニメーションを削減しました');
                        } else {
                            document.body.classList.remove('reduced-motion');
                        }
                    };

                    // 初期設定
                    handleReducedMotion(prefersReducedMotion);

                    // 設定変更の監視
                    prefersReducedMotion.addEventListener('change', handleReducedMotion);

                    // 手動切り替えボタン
                    const motionToggle = document.createElement('button');
                    motionToggle.textContent = 'アニメーション削減';
                    motionToggle.setAttribute('aria-label', 'アニメーション削減モード切り替え');
                    motionToggle.className = 'motion-toggle-btn';

                    motionToggle.addEventListener('click', () => {
                        document.body.classList.toggle('reduced-motion');
                        const isReduced = document.body.classList.contains('reduced-motion');
                        motionToggle.textContent = isReduced ? 'アニメーション有効' : 'アニメーション削減';
                        this.announceToScreenReader(
                            isReduced ? 'アニメーションを削減しました' : 'アニメーションを有効にしました'
                        );
                    });

                    // 設定パネルに追加
                    const settingsPanel = Utils.getElement('settingsPanel', false);
                    if (settingsPanel) {
                        settingsPanel.appendChild(motionToggle);
                    }

                    // 削減モーションスタイル
                    const motionStyle = document.createElement('style');
                    motionStyle.textContent = `
                        .reduced-motion * {
                            animation-duration: 0.01ms !important;
                            animation-iteration-count: 1 !important;
                            transition-duration: 0.01ms !important;
                            scroll-behavior: auto !important;
                        }
                        
                        .motion-toggle-btn {
                            background: #059669;
                            color: white;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 4px;
                            cursor: pointer;
                            margin: 10px 0;
                        }
                        
                        .motion-toggle-btn:hover {
                            background: #047857;
                        }
                    `;
                    document.head.appendChild(motionStyle);
                }
            };

            // ===== モジュール6: パフォーマンス最適化 =====
            const PerformanceOptimizer = {
                init() {
                    this.setupLazyLoading();
                    this.setupVirtualScrolling();
                    this.setupImageOptimization();
                    this.setupMemoryManagement();
                    this.setupWebWorkers();

                    console.log('PerformanceOptimizer initialized successfully');
                },

                setupLazyLoading() {
                    // Intersection Observer for lazy loading
                    const lazyObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const element = entry.target;

                                // 画像の遅延読み込み
                                if (element.hasAttribute('data-src')) {
                                    element.src = element.getAttribute('data-src');
                                    element.removeAttribute('data-src');
                                }

                                // コンテンツの遅延読み込み
                                if (element.hasAttribute('data-lazy-content')) {
                                    this.loadLazyContent(element);
                                }

                                lazyObserver.unobserve(element);
                            }
                        });
                    }, {
                        rootMargin: '50px'
                    });

                    // 遅延読み込み対象要素を監視
                    document.querySelectorAll('[data-src], [data-lazy-content]').forEach(element => {
                        lazyObserver.observe(element);
                    });
                },

                loadLazyContent(element) {
                    const contentType = element.getAttribute('data-lazy-content');

                    switch (contentType) {
                        case 'animation':
                            this.loadAnimationContent(element);
                            break;
                        case 'chart':
                            this.loadChartContent(element);
                            break;
                        case 'code':
                            this.loadCodeContent(element);
                            break;
                        default:
                            console.warn('Unknown lazy content type:', contentType);
                    }
                },

                loadAnimationContent(element) {
                    // アニメーションコンテンツの動的読み込み
                    const placeholder = element.querySelector('.lazy-placeholder');
                    if (placeholder) {
                        placeholder.textContent = 'アニメーションを読み込み中...';

                        // 実際のアニメーション要素を作成
                        setTimeout(() => {
                            const animationContainer = document.createElement('div');
                            animationContainer.className = 'animation-container';
                            animationContainer.innerHTML = `
                                <div class="fsm-visualization">
                                    <div class="state-nodes"></div>
                                    <div class="transitions"></div>
                                </div>
                            `;

                            element.replaceChild(animationContainer, placeholder);

                            // アニメーション初期化
                            if (typeof AnimationController !== 'undefined') {
                                AnimationController.initializeVisualization(animationContainer);
                            }
                        }, 100);
                    }
                },

                loadChartContent(element) {
                    // チャートコンテンツの動的読み込み
                    const placeholder = element.querySelector('.lazy-placeholder');
                    if (placeholder) {
                        placeholder.textContent = 'チャートを読み込み中...';

                        setTimeout(() => {
                            const chartContainer = document.createElement('div');
                            chartContainer.className = 'chart-container';
                            chartContainer.innerHTML = `
                                <canvas id="performanceChart" width="400" height="200"></canvas>
                            `;

                            element.replaceChild(chartContainer, placeholder);

                            // チャート描画
                            this.drawPerformanceChart(chartContainer.querySelector('canvas'));
                        }, 100);
                    }
                },


                loadCodeContent(element) {
                    // コードコンテンツの動的読み込み
                    const placeholder = element.querySelector('.lazy-placeholder');
                    if (placeholder) {
                        const codeType = element.getAttribute('data-code-type') || 'javascript';
                        placeholder.textContent = `${codeType}コードを読み込み中...`;

                        setTimeout(() => {
                            const codeContainer = document.createElement('div');
                            codeContainer.className = 'code-container';

                            // コードタイプに応じたサンプルコードを生成
                            const sampleCode = this.generateSampleCode(codeType);

                            codeContainer.innerHTML = `
                                <div class="code-header">
                                    <span class="code-language">${codeType}</span>
                                    <button class="copy-btn" data-copy-target="code-${Date.now()}">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                                  d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                        </svg>
                                        コピー
                                    </button>
                                </div>
                                <pre class="code-block" id="code-${Date.now()}"><code class="language-${codeType}">${sampleCode}</code></pre>
                            `;

                            element.replaceChild(codeContainer, placeholder);

                            // シンタックスハイライト適用
                            if (typeof Prism !== 'undefined') {
                                Prism.highlightElement(codeContainer.querySelector('code'));
                            }
                        }, 100);
                    }
                },

                generateSampleCode(codeType) {
                    const samples = {
                        javascript: `function isValidNumber(s) {
    const states = {
        start: 0, sign: 1, integer: 2, point: 3,
        fraction: 4, exp: 5, expSign: 6, expNum: 7
    };
    
    let state = states.start;
    
    for (const char of s.trim()) {
        state = getNextState(state, char);
        if (state === -1) return false;
    }
    
    return [states.integer, states.fraction, states.expNum].includes(state);
}`,
                        python: `def is_valid_number(s: str) -> bool:
    states = {
        'start': 0, 'sign': 1, 'integer': 2, 'point': 3,
        'fraction': 4, 'exp': 5, 'exp_sign': 6, 'exp_num': 7
    }
    
    state = states['start']
    
    for char in s.strip():
        state = get_next_state(state, char)
        if state == -1:
            return False
    
    return state in [states['integer'], states['fraction'], states['exp_num']]`,
                        java: `public boolean isNumber(String s) {
    enum State {
        START, SIGN, INTEGER, POINT, FRACTION, EXP, EXP_SIGN, EXP_NUM
    }
    
    State state = State.START;
    s = s.trim();
    
    for (char c : s.toCharArray()) {
        state = getNextState(state, c);
        if (state == null) return false;
    }
    
    return state == State.INTEGER || state == State.FRACTION || state == State.EXP_NUM;
}`,
                        cpp: `bool isNumber(string s) {
    enum State {
        START, SIGN, INTEGER, POINT, FRACTION, EXP, EXP_SIGN, EXP_NUM
    };
    
    State state = START;
    
    for (char c : s) {
        if (c == ' ') continue;
        state = getNextState(state, c);
        if (state == -1) return false;
    }
    
    return state == INTEGER || state == FRACTION || state == EXP_NUM;
}`
                    };

                    return samples[codeType] || samples.javascript;
                },

                setupVirtualScrolling() {
                    // 大量のデータを効率的に表示するための仮想スクロール
                    const virtualContainers = document.querySelectorAll('[data-virtual-scroll]');

                    virtualContainers.forEach(container => {
                        this.initVirtualScroll(container);
                    });
                },

                initVirtualScroll(container) {
                    const itemHeight = parseInt(container.getAttribute('data-item-height')) || 50;
                    const bufferSize = parseInt(container.getAttribute('data-buffer-size')) || 5;

                    let scrollTop = 0;
                    let containerHeight = container.clientHeight;
                    let totalItems = parseInt(container.getAttribute('data-total-items')) || 0;

                    const updateVisibleItems = () => {
                        const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - bufferSize);
                        const endIndex = Math.min(totalItems, Math.ceil((scrollTop + containerHeight) / itemHeight) + bufferSize);

                        // 表示アイテムを更新
                        this.renderVirtualItems(container, startIndex, endIndex, itemHeight);
                    };

                    container.addEventListener('scroll', () => {
                        scrollTop = container.scrollTop;
                        requestAnimationFrame(updateVisibleItems);
                    });

                    // 初期表示
                    updateVisibleItems();
                },

                renderVirtualItems(container, startIndex, endIndex, itemHeight) {
                    // 仮想アイテムのレンダリング実装
                    const content = container.querySelector('.virtual-content') || container;

                    // 既存のアイテムをクリア
                    content.innerHTML = '';

                    // 上部スペーサー
                    if (startIndex > 0) {
                        const topSpacer = document.createElement('div');
                        topSpacer.style.height = `${startIndex * itemHeight}px`;
                        content.appendChild(topSpacer);
                    }

                    // 表示アイテム
                    for (let i = startIndex; i < endIndex; i++) {
                        const item = this.createVirtualItem(i, itemHeight);
                        content.appendChild(item);
                    }

                    // 下部スペーサー
                    const totalItems = parseInt(container.getAttribute('data-total-items')) || 0;
                    if (endIndex < totalItems) {
                        const bottomSpacer = document.createElement('div');
                        bottomSpacer.style.height = `${(totalItems - endIndex) * itemHeight}px`;
                        content.appendChild(bottomSpacer);
                    }
                },

                createVirtualItem(index, height) {
                    const item = document.createElement('div');
                    item.className = 'virtual-item';
                    item.style.height = `${height}px`;
                    item.textContent = `アイテム ${index + 1}`;
                    return item;
                },

                setupImageOptimization() {
                    // 画像の最適化と遅延読み込み
                    const images = document.querySelectorAll('img[data-src]');

                    const imageObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const img = entry.target;
                                this.loadOptimizedImage(img);
                                imageObserver.unobserve(img);
                            }
                        });
                    });

                    images.forEach(img => imageObserver.observe(img));
                },

                loadOptimizedImage(img) {
                    const src = img.getAttribute('data-src');
                    const placeholder = img.getAttribute('data-placeholder');

                    // プレースホルダー表示
                    if (placeholder) {
                        img.src = placeholder;
                    }

                    // 実際の画像を読み込み
                    const actualImg = new Image();
                    actualImg.onload = () => {
                        img.src = actualImg.src;
                        img.classList.add('loaded');
                    };
                    actualImg.onerror = () => {
                        img.classList.add('error');
                        console.error('Image load failed:', src);
                    };
                    actualImg.src = src;
                },

                setupMemoryManagement() {
                    // メモリ使用量の監視と最適化
                    let memoryCheckInterval;

                    const startMemoryMonitoring = () => {
                        if ('memory' in performance) {
                            memoryCheckInterval = setInterval(() => {
                                const memory = performance.memory;
                                const usedMB = Math.round(memory.usedJSHeapSize / 1048576);
                                const limitMB = Math.round(memory.jsHeapSizeLimit / 1048576);

                                // メモリ使用量が80%を超えた場合の警告
                                if (usedMB / limitMB > 0.8) {
                                    console.warn('High memory usage detected:', usedMB, 'MB /', limitMB, 'MB');
                                    this.performMemoryCleanup();
                                }
                            }, 30000); // 30秒ごとにチェック
                        }
                    };

                    const stopMemoryMonitoring = () => {
                        if (memoryCheckInterval) {
                            clearInterval(memoryCheckInterval);
                        }
                    };

                    // ページの可視性に応じてモニタリングを制御
                    document.addEventListener('visibilitychange', () => {
                        if (document.hidden) {
                            stopMemoryMonitoring();
                        } else {
                            startMemoryMonitoring();
                        }
                    });

                    startMemoryMonitoring();
                },

                performMemoryCleanup() {
                    // 不要なDOMノードの削除
                    const hiddenElements = document.querySelectorAll('.hidden, [style*="display: none"]');
                    hiddenElements.forEach(element => {
                        if (element.getAttribute('data-keep') !== 'true') {
                            element.remove();
                        }
                    });

                    // イベントリスナーのクリーンアップ
                    this.cleanupEventListeners();

                    // ガベージコレクションの強制実行（可能な場合）
                    if (window.gc) {
                        window.gc();
                    }
                },



                cleanupEventListeners() {
                    // 不要なイベントリスナーを削除
                    const elementsWithListeners = document.querySelectorAll('[data-cleanup-listeners]');
                    elementsWithListeners.forEach(element => {
                        const newElement = element.cloneNode(true);
                        element.parentNode.replaceChild(newElement, element);
                    });

                    // グローバルイベントリスナーのクリーンアップ
                    const globalListeners = this.globalEventListeners || [];
                    globalListeners.forEach(({ target, type, listener, options }) => {
                        target.removeEventListener(type, listener, options);
                    });
                    this.globalEventListeners = [];

                    // タイマーのクリーンアップ
                    if (this.activeTimers) {
                        this.activeTimers.forEach(timerId => {
                            clearTimeout(timerId);
                            clearInterval(timerId);
                        });
                        this.activeTimers = [];
                    }

                    // オブザーバーのクリーンアップ
                    if (this.activeObservers) {
                        this.activeObservers.forEach(observer => {
                            observer.disconnect();
                        });
                        this.activeObservers = [];
                    }
                },

                addGlobalEventListener(target, type, listener, options = {}) {
                    // グローバルイベントリスナーを追跡可能な形で追加
                    target.addEventListener(type, listener, options);

                    if (!this.globalEventListeners) {
                        this.globalEventListeners = [];
                    }

                    this.globalEventListeners.push({
                        target,
                        type,
                        listener,
                        options
                    });
                },

                addTimer(callback, delay, isInterval = false) {
                    // タイマーを追跡可能な形で追加
                    const timerId = isInterval ?
                        setInterval(callback, delay) :
                        setTimeout(callback, delay);

                    if (!this.activeTimers) {
                        this.activeTimers = [];
                    }

                    this.activeTimers.push(timerId);
                    return timerId;
                },


                addObserver(observer) {
                    // オブザーバーを追跡可能な形で追加
                    if (!this.activeObservers) {
                        this.activeObservers = [];
                    }

                    this.activeObservers.push(observer);
                    return observer;
                },

                setupProgressiveLoading() {
                    // プログレッシブローディングの設定
                    const lazyElements = document.querySelectorAll('[data-lazy-load]');

                    const loadObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                this.loadElement(entry.target);
                                loadObserver.unobserve(entry.target);
                            }
                        });
                    }, {
                        rootMargin: '50px'
                    });

                    lazyElements.forEach(element => {
                        loadObserver.observe(element);
                    });

                    this.addObserver(loadObserver);
                },

                loadElement(element) {
                    const loadType = element.getAttribute('data-lazy-load');

                    switch (loadType) {
                        case 'content':
                            this.loadContentElement(element);
                            break;
                        case 'image':
                            this.loadImageElement(element);
                            break;
                        case 'component':
                            this.loadComponentElement(element);
                            break;
                        default:
                            console.warn('Unknown lazy load type:', loadType);
                    }
                },

                loadContentElement(element) {
                    const contentUrl = element.getAttribute('data-content-url');
                    if (contentUrl) {
                        fetch(contentUrl)
                            .then(response => response.text())
                            .then(html => {
                                element.innerHTML = html;
                                element.classList.add('loaded');
                            })
                            .catch(error => {
                                console.error('Content load failed:', error);
                                element.classList.add('error');
                            });
                    }
                },

                loadImageElement(element) {
                    const imageSrc = element.getAttribute('data-src');
                    if (imageSrc && element.tagName === 'IMG') {
                        element.src = imageSrc;
                        element.onload = () => element.classList.add('loaded');
                        element.onerror = () => element.classList.add('error');
                    }
                },

                loadComponentElement(element) {
                    const componentName = element.getAttribute('data-component');
                    if (componentName && window[componentName]) {
                        try {
                            window[componentName].init(element);
                            element.classList.add('loaded');
                        } catch (error) {
                            console.error('Component load failed:', error);
                            element.classList.add('error');
                        }
                    }
                },

                setupAccessibilityEnhancements() {
                    // アクセシビリティの向上
                    this.setupKeyboardNavigation();
                    this.setupScreenReaderSupport();
                    this.setupFocusManagement();
                    this.setupColorContrastAdjustment();
                },

                setupKeyboardNavigation() {
                    // キーボードナビゲーションの設定
                    document.addEventListener('keydown', (e) => {
                        // Tab キーでのフォーカス管理
                        if (e.key === 'Tab') {
                            this.handleTabNavigation(e);
                        }

                        // Arrow キーでのナビゲーション
                        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                            this.handleArrowNavigation(e);
                        }

                        // Enter/Space キーでのアクティベーション
                        if (e.key === 'Enter' || e.key === ' ') {
                            this.handleActivation(e);
                        }
                    });
                },

                handleTabNavigation(e) {
                    const focusableElements = document.querySelectorAll(
                        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                    );

                    const firstElement = focusableElements[0];
                    const lastElement = focusableElements[focusableElements.length - 1];

                    if (e.shiftKey && document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    } else if (!e.shiftKey && document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                },

                handleArrowNavigation(e) {
                    const currentElement = document.activeElement;
                    const navigationGroup = currentElement.closest('[data-keyboard-nav]');

                    if (navigationGroup) {
                        const items = navigationGroup.querySelectorAll('[data-nav-item]');
                        const currentIndex = Array.from(items).indexOf(currentElement);

                        let nextIndex;
                        switch (e.key) {
                            case 'ArrowUp':
                            case 'ArrowLeft':
                                nextIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
                                break;
                            case 'ArrowDown':
                            case 'ArrowRight':
                                nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
                                break;
                        }

                        if (nextIndex !== undefined && items[nextIndex]) {
                            e.preventDefault();
                            items[nextIndex].focus();
                        }
                    }
                },

                handleActivation(e) {
                    const element = e.target;

                    if (element.hasAttribute('data-keyboard-activate')) {
                        e.preventDefault();
                        element.click();
                    }
                },

                setupScreenReaderSupport() {
                    // スクリーンリーダー対応
                    const announcements = document.createElement('div');
                    announcements.id = 'sr-announcements';
                    announcements.setAttribute('aria-live', 'polite');
                    announcements.setAttribute('aria-atomic', 'true');
                    announcements.style.cssText = `
                        position: absolute;
                        left: -10000px;
                        width: 1px;
                        height: 1px;
                        overflow: hidden;
                    `;
                    document.body.appendChild(announcements);

                    this.srAnnouncements = announcements;
                },

                announceToScreenReader(message, priority = 'polite') {
                    if (this.srAnnouncements) {
                        this.srAnnouncements.setAttribute('aria-live', priority);
                        this.srAnnouncements.textContent = message;

                        // 短時間後にクリア
                        setTimeout(() => {
                            this.srAnnouncements.textContent = '';
                        }, 1000);
                    }
                },

                setupFocusManagement() {
                    // フォーカス管理の設定
                    let lastFocusedElement = null;

                    document.addEventListener('focusin', (e) => {
                        lastFocusedElement = e.target;
                    });

                    // モーダルやダイアログのフォーカストラップ
                    document.addEventListener('keydown', (e) => {
                        const modal = document.querySelector('.modal:not(.hidden)');
                        if (modal && e.key === 'Tab') {
                            this.trapFocusInModal(e, modal);
                        }
                    });

                    // フォーカス復帰機能
                    window.restoreFocus = () => {
                        if (lastFocusedElement && document.contains(lastFocusedElement)) {
                            lastFocusedElement.focus();
                        }
                    };
                },

                trapFocusInModal(e, modal) {
                    const focusableElements = modal.querySelectorAll(
                        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                    );

                    const firstElement = focusableElements[0];
                    const lastElement = focusableElements[focusableElements.length - 1];

                    if (e.shiftKey && document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    } else if (!e.shiftKey && document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                },

                setupColorContrastAdjustment() {
                    // カラーコントラストの調整機能
                    const contrastToggle = document.getElementById('contrast-toggle');
                    if (contrastToggle) {
                        contrastToggle.addEventListener('click', () => {
                            document.body.classList.toggle('high-contrast');
                            const isHighContrast = document.body.classList.contains('high-contrast');

                            localStorage.setItem('high-contrast', isHighContrast);
                            this.announceToScreenReader(
                                isHighContrast ? 'ハイコントラストモードを有効にしました' : 'ハイコントラストモードを無効にしました'
                            );
                        });

                        // 保存された設定を復元
                        if (localStorage.getItem('high-contrast') === 'true') {
                            document.body.classList.add('high-contrast');
                        }
                    }
                }
            };


            // ===== モジュール6: ErrorHandler =====
            const ErrorHandler = {
                errors: [],
                maxErrors: 100,
                isDev: true,

                init() {
                    this.setupGlobalErrorHandling();
                    this.setupUnhandledRejectionHandling();
                    this.setupPerformanceMonitoring();
                    console.log('ErrorHandler initialized successfully');
                },

                setupGlobalErrorHandling() {
                    window.addEventListener('error', (event) => {
                        this.logError({
                            type: 'JavaScript Error',
                            message: event.message,
                            filename: event.filename,
                            lineno: event.lineno,
                            colno: event.colno,
                            stack: event.error?.stack,
                            timestamp: new Date().toISOString()
                        });
                    });
                },

                setupUnhandledRejectionHandling() {
                    window.addEventListener('unhandledrejection', (event) => {
                        this.logError({
                            type: 'Unhandled Promise Rejection',
                            message: event.reason?.message || 'Unknown rejection',
                            stack: event.reason?.stack,
                            timestamp: new Date().toISOString()
                        });
                    });
                },

                setupPerformanceMonitoring() {
                    // レイアウトシフト監視（閾値を上げて重要なもののみ検出）
                    if ('LayoutShift' in window) {
                        const observer = new PerformanceObserver((list) => {
                            for (const entry of list.getEntries()) {
                                // 閾値を0.1から0.25に上げて、重要なレイアウトシフトのみ検出
                                if (entry.value > 0.25 && !entry.hadRecentInput) {
                                    this.logLayoutShift(entry.value);
                                }
                            }
                        });

                        try {
                            observer.observe({ entryTypes: ['layout-shift'] });
                        } catch (e) {
                            console.warn('Layout shift monitoring not supported');
                        }
                    }

                    // ロングタスク監視（閾値を上げる）
                    if ('PerformanceObserver' in window) {
                        const longTaskObserver = new PerformanceObserver((list) => {
                            for (const entry of list.getEntries()) {
                                // 閾値を50msから200msに上げて、本当に問題のあるタスクのみ検出
                                if (entry.duration > 200) {
                                    this.logLongTask(entry.duration, entry.startTime);
                                }
                            }
                        });

                        try {
                            longTaskObserver.observe({ entryTypes: ['longtask'] });
                        } catch (e) {
                            console.warn('Long task monitoring not supported');
                        }
                    }
                },

                logLayoutShift(value) {
                    // 開発環境でのみログ出力を制限
                    if (this.isDev && value > 0.5) { // さらに閾値を上げる
                        this.logError({
                            type: 'Layout Shift',
                            message: `Significant layout shift detected: ${value}`,
                            value: value,
                            timestamp: new Date().toISOString()
                        });
                    }
                },

                logLongTask(duration, startTime) {
                    // 開発環境でのみログ出力を制限
                    if (this.isDev && duration > 300) { // さらに閾値を上げる
                        this.logError({
                            type: 'Performance Warning',
                            message: `Long task detected: ${duration}ms`,
                            duration: duration,
                            startTime: startTime,
                            timestamp: new Date().toISOString()
                        });
                    }
                },

                logError(error) {
                    // エラーログの頻度制限
                    const now = Date.now();
                    const recentErrors = this.errors.filter(e =>
                        now - new Date(e.timestamp).getTime() < 5000 // 5秒以内
                    );

                    // 同じタイプのエラーが短時間に多発している場合はスキップ
                    const sameTypeCount = recentErrors.filter(e => e.type === error.type).length;
                    if (sameTypeCount > 3) {
                        return; // 同じタイプのエラーが5秒間に3回以上発生した場合はスキップ
                    }

                    this.errors.push(error);

                    // エラー配列のサイズ制限
                    if (this.errors.length > this.maxErrors) {
                        this.errors = this.errors.slice(-this.maxErrors);
                    }

                    // 開発環境でのみコンソール出力
                    if (this.isDev) {
                        // レイアウトシフトとロングタスクは警告レベルに下げる
                        if (error.type === 'Layout Shift' || error.type === 'Performance Warning') {
                            console.warn('Performance issue:', error);
                        } else {
                            console.error('Error logged:', error);
                        }
                    }
                },

                getErrors() {
                    return [...this.errors];
                },

                clearErrors() {
                    this.errors = [];
                },

                isDevelopment() {
                    return this.isDev;
                },

                setDevelopmentMode(isDev) {
                    this.isDev = isDev;
                },

                cleanup() {
                    this.errors = [];
                }
            };

            // ===== モジュール7: PerformanceMonitor =====
            const PerformanceMonitor = {
                metrics: {
                    memoryUsage: null,
                    renderTime: null,
                    interactionTime: null
                },
                observers: [],

                init() {
                    this.setupMemoryMonitoring();
                    this.setupRenderTimeMonitoring();
                    this.setupInteractionMonitoring();
                    console.log('PerformanceMonitor initialized successfully');
                },

                setupMemoryMonitoring() {
                    if ('memory' in performance) {
                        // メモリ監視の頻度を下げる（10秒ごと）
                        setInterval(() => {
                            this.metrics.memoryUsage = {
                                used: performance.memory.usedJSHeapSize,
                                total: performance.memory.totalJSHeapSize,
                                limit: performance.memory.jsHeapSizeLimit,
                                timestamp: Date.now()
                            };
                        }, 10000); // 1秒から10秒に変更
                    }
                },

                setupRenderTimeMonitoring() {
                    // First Contentful Paint の監視
                    if ('PerformanceObserver' in window) {
                        const paintObserver = new PerformanceObserver((list) => {
                            for (const entry of list.getEntries()) {
                                if (entry.name === 'first-contentful-paint') {
                                    this.metrics.renderTime = {
                                        fcp: entry.startTime,
                                        timestamp: Date.now()
                                    };
                                }
                            }
                        });

                        try {
                            paintObserver.observe({ entryTypes: ['paint'] });
                            this.observers.push(paintObserver);
                        } catch (e) {
                            console.warn('Paint timing monitoring not supported');
                        }
                    }
                },

                setupInteractionMonitoring() {
                    // ユーザーインタラクションの応答時間監視
                    let interactionStart = null;

                    const startInteraction = () => {
                        interactionStart = performance.now();
                    };

                    const endInteraction = () => {
                        if (interactionStart) {
                            const duration = performance.now() - interactionStart;
                            this.metrics.interactionTime = {
                                duration: duration,
                                timestamp: Date.now()
                            };
                            interactionStart = null;

                            // 応答時間が遅い場合のみログ（閾値を上げる）
                            if (duration > 200) { // 100msから200msに変更
                                console.warn(`Slow interaction detected: ${duration.toFixed(2)}ms`);
                            }
                        }
                    };

                    // イベントリスナーを追加（パッシブオプションでパフォーマンス向上）
                    document.addEventListener('click', startInteraction, { passive: true });
                    document.addEventListener('keydown', startInteraction, { passive: true });

                    // 少し遅延させて測定
                    setTimeout(() => {
                        document.addEventListener('click', endInteraction, { passive: true });
                        document.addEventListener('keyup', endInteraction, { passive: true });
                    }, 0);
                },

                getPerformanceReport() {
                    return {
                        memory: this.metrics.memoryUsage,
                        render: this.metrics.renderTime,
                        interaction: this.metrics.interactionTime,
                        timestamp: new Date().toISOString()
                    };
                },

                // レイアウトシフトを最小化するためのユーティリティ
                preventLayoutShift(element, callback) {
                    if (!element) return;

                    // 要素の現在のサイズを記録
                    const rect = element.getBoundingClientRect();
                    const computedStyle = window.getComputedStyle(element);

                    // 一時的にサイズを固定
                    const originalHeight = element.style.height;
                    const originalMinHeight = element.style.minHeight;

                    element.style.height = rect.height + 'px';
                    element.style.minHeight = rect.height + 'px';

                    // コールバック実行
                    if (typeof callback === 'function') {
                        callback();
                    }

                    // 次のフレームでサイズ制限を解除
                    requestAnimationFrame(() => {
                        element.style.height = originalHeight;
                        element.style.minHeight = originalMinHeight;
                    });
                },

                // バッチ処理でDOMの更新を最適化
                batchDOMUpdates(updates) {
                    return new Promise((resolve) => {
                        requestAnimationFrame(() => {
                            updates.forEach(update => {
                                if (typeof update === 'function') {
                                    update();
                                }
                            });
                            resolve();
                        });
                    });
                },

                cleanup() {
                    // オブザーバーのクリーンアップ
                    this.observers.forEach(observer => {
                        try {
                            observer.disconnect();
                        } catch (e) {
                            console.warn('Failed to disconnect observer:', e);
                        }
                    });
                    this.observers = [];

                    // メトリクスのリセット
                    this.metrics = {
                        memoryUsage: null,
                        renderTime: null,
                        interactionTime: null
                    };
                }
            };

            // ===== モジュール4: TestRunner =====
            const TestRunner = {
                testCases: [],
                currentTestIndex: 0,
                testResults: [],
                isRunning: false,

                init() {
                    this.setupTestCases();
                    this.bindEvents();
                    this.setupTestDisplay();
                    console.log('TestRunner initialized successfully');
                },

                setupTestCases() {
                    // 有効なテストケース
                    const validCases = [
                        { input: "2", expected: true, description: "整数" },
                        { input: "0089", expected: true, description: "先頭ゼロ付き整数" },
                        { input: "-0.1", expected: true, description: "負の小数" },
                        { input: "+3.14", expected: true, description: "正の小数" },
                        { input: "4.", expected: true, description: "整数部のみの小数" },
                        { input: "-.9", expected: true, description: "整数部なしの負の小数" },
                        { input: "2e10", expected: true, description: "指数記法" },
                        { input: "-90E3", expected: true, description: "負の指数記法" },
                        { input: "3e+7", expected: true, description: "正の指数" },
                        { input: "+6e-1", expected: true, description: "負の指数" },
                        { input: "53.5e93", expected: true, description: "小数の指数記法" },
                        { input: "-123.456e789", expected: true, description: "複雑な指数記法" }
                    ];

                    // 無効なテストケース
                    const invalidCases = [
                        { input: "abc", expected: false, description: "文字列" },
                        { input: "1a", expected: false, description: "数字+文字" },
                        { input: "1e", expected: false, description: "不完全な指数" },
                        { input: "e3", expected: false, description: "指数のみ" },
                        { input: "99e2.5", expected: false, description: "指数部に小数点" },
                        { input: "--6", expected: false, description: "二重マイナス" },
                        { input: "-+3", expected: false, description: "マイナス+プラス" },
                        { input: "95a54e53", expected: false, description: "文字混在" },
                        { input: ".", expected: false, description: "小数点のみ" },
                        { input: " ", expected: false, description: "空白のみ" },
                        { input: "", expected: false, description: "空文字" }
                    ];

                    this.testCases = [...validCases, ...invalidCases];
                },

                bindEvents() {
                    const runAllBtn = Utils.getElement('runAllTestsBtn', false);
                    const runSingleBtn = Utils.getElement('runSingleTestBtn', false);
                    const clearResultsBtn = Utils.getElement('clearResultsBtn', false);

                    if (runAllBtn) {
                        runAllBtn.addEventListener('click', () => this.runAllTests());
                    }
                    if (runSingleBtn) {
                        runSingleBtn.addEventListener('click', () => this.runSingleTest());
                    }
                    if (clearResultsBtn) {
                        clearResultsBtn.addEventListener('click', () => this.clearResults());
                    }
                },

                setupTestDisplay() {
                    const testContainer = Utils.getElement('testContainer', false);
                    if (testContainer) {
                        testContainer.innerHTML = `
                            <div class="test-controls">
                                <button id="runAllTestsBtn" class="demo-button">
                                    <span class="button-icon">🧪</span>
                                    全テスト実行
                                </button>
                                <button id="runSingleTestBtn" class="demo-button">
                                    <span class="button-icon">🔍</span>
                                    単体テスト実行
                                </button>
                                <button id="clearResultsBtn" class="demo-button">
                                    <span class="button-icon">🗑️</span>
                                    結果クリア
                                </button>
                            </div>
                            <div class="test-selector">
                                <label for="testCaseSelect">テストケース選択:</label>
                                <select id="testCaseSelect">
                                    ${this.testCases.map((test, index) =>
                            `<option value="${index}">${index + 1}. "${test.input}" - ${test.description}</option>`
                        ).join('')}
                                </select>
                            </div>
                            <div id="testResults" class="test-results"></div>
                            <div id="testSummary" class="test-summary"></div>
                        `;

                        // イベントリスナーを再バインド
                        this.bindEvents();
                    }
                },

                async runAllTests() {
                    if (this.isRunning) return;

                    this.isRunning = true;
                    this.testResults = [];
                    this.updateRunButton(true);

                    const resultsContainer = Utils.getElement('testResults');
                    if (resultsContainer) {
                        resultsContainer.innerHTML = '<div class="test-progress">テスト実行中...</div>';
                    }

                    let passed = 0;
                    let failed = 0;

                    for (let i = 0; i < this.testCases.length; i++) {
                        const testCase = this.testCases[i];
                        const startTime = performance.now();

                        try {
                            const result = FSMSimulator.isNumber(testCase.input);
                            const endTime = performance.now();
                            const executionTime = endTime - startTime;

                            const testResult = {
                                index: i,
                                input: testCase.input,
                                expected: testCase.expected,
                                actual: result,
                                passed: result === testCase.expected,
                                executionTime: executionTime,
                                description: testCase.description
                            };

                            this.testResults.push(testResult);

                            if (testResult.passed) {
                                passed++;
                            } else {
                                failed++;
                            }

                            // リアルタイムで結果を更新
                            this.updateTestDisplay();

                            // 少し待機してUIの応答性を保つ
                            await new Promise(resolve => setTimeout(resolve, 10));

                        } catch (error) {
                            console.error(`Test ${i + 1} failed with error:`, error);
                            this.testResults.push({
                                index: i,
                                input: testCase.input,
                                expected: testCase.expected,
                                actual: null,
                                passed: false,
                                executionTime: 0,
                                description: testCase.description,
                                error: error.message
                            });
                            failed++;
                        }
                    }

                    this.updateSummary(passed, failed);
                    this.isRunning = false;
                    this.updateRunButton(false);
                },

                runSingleTest() {
                    const testSelect = Utils.getElement('testCaseSelect');
                    if (!testSelect) return;

                    const testIndex = parseInt(testSelect.value);
                    const testCase = this.testCases[testIndex];

                    if (!testCase) return;

                    const startTime = performance.now();
                    try {
                        const result = FSMSimulator.isNumber(testCase.input);
                        const endTime = performance.now();
                        const executionTime = endTime - startTime;

                        const testResult = {
                            index: testIndex,
                            input: testCase.input,
                            expected: testCase.expected,
                            actual: result,
                            passed: result === testCase.expected,
                            executionTime: executionTime,
                            description: testCase.description
                        };

                        // 単体テスト結果を表示
                        this.displaySingleTestResult(testResult);

                        // トレースデータがあればアニメーションコントローラーに設定
                        if (FSMSimulator.lastTrace) {
                            AnimationController.setTraceData(FSMSimulator.lastTrace);
                        }

                    } catch (error) {
                        console.error(`Single test failed:`, error);
                        this.displaySingleTestResult({
                            index: testIndex,
                            input: testCase.input,
                            expected: testCase.expected,
                            actual: null,
                            passed: false,
                            executionTime: 0,
                            description: testCase.description,
                            error: error.message
                        });
                    }
                },

                displaySingleTestResult(testResult) {
                    const resultsContainer = Utils.getElement('testResults');
                    if (!resultsContainer) return;

                    const statusIcon = testResult.passed ? '✅' : '❌';
                    const statusClass = testResult.passed ? 'test-passed' : 'test-failed';

                    resultsContainer.innerHTML = `
                        <div class="single-test-result ${statusClass}">
                            <div class="test-header">
                                <span class="test-status">${statusIcon}</span>
                                <span class="test-title">テスト ${testResult.index + 1}: ${testResult.description}</span>
                            </div>
                            <div class="test-details">
                                <div class="test-input">入力: "${testResult.input}"</div>
                                <div class="test-expected">期待値: ${testResult.expected}</div>
                                <div class="test-actual">実際の値: ${testResult.actual}</div>
                                <div class="test-time">実行時間: ${testResult.executionTime.toFixed(3)}ms</div>
                                ${testResult.error ? `<div class="test-error">エラー: ${testResult.error}</div>` : ''}
                            </div>
                        </div>
                    `;
                },

                updateTestDisplay() {
                    const resultsContainer = Utils.getElement('testResults');
                    if (!resultsContainer || this.testResults.length === 0) return;

                    const resultsHTML = this.testResults.map(result => {
                        const statusIcon = result.passed ? '✅' : '❌';
                        const statusClass = result.passed ? 'test-passed' : 'test-failed';

                        return `
                            <div class="test-result-item ${statusClass}">
                                <div class="test-summary-line">
                                    <span class="test-status">${statusIcon}</span>
                                    <span class="test-number">#${result.index + 1}</span>
                                    <span class="test-input">"${result.input}"</span>
                                    <span class="test-description">${result.description}</span>
                                    <span class="test-time">${result.executionTime.toFixed(2)}ms</span>
                                </div>
                                ${!result.passed ? `
                                    <div class="test-details">
                                        <div class="test-expected">期待値: ${result.expected}</div>
                                        <div class="test-actual">実際の値: ${result.actual}</div>
                                        ${result.error ? `<div class="test-error">エラー: ${result.error}</div>` : ''}
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    }).join('');

                    resultsContainer.innerHTML = `
                        <div class="test-results-container">
                            <div class="test-progress">
                                進行状況: ${this.testResults.length} / ${this.testCases.length} テスト完了
                            </div>
                            <div class="test-results-list">
                                ${resultsHTML}
                            </div>
                        </div>
                    `;
                },

                updateSummary(passed, failed) {
                    const summaryContainer = Utils.getElement('testSummary');
                    if (!summaryContainer) return;

                    const total = passed + failed;
                    const passRate = total > 0 ? ((passed / total) * 100).toFixed(1) : 0;

                    summaryContainer.innerHTML = `
                        <div class="test-summary-content">
                            <h3>テスト結果サマリー</h3>
                            <div class="summary-stats">
                                <div class="stat-item">
                                    <span class="stat-label">総テスト数:</span>
                                    <span class="stat-value">${total}</span>
                                </div>
                                <div class="stat-item passed">
                                    <span class="stat-label">成功:</span>
                                    <span class="stat-value">${passed}</span>
                                </div>
                                <div class="stat-item failed">
                                    <span class="stat-label">失敗:</span>
                                    <span class="stat-value">${failed}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">成功率:</span>
                                    <span class="stat-value">${passRate}%</span>
                                </div>
                            </div>
                            <div class="summary-status ${failed === 0 ? 'all-passed' : 'has-failures'}">
                                ${failed === 0 ? '🎉 すべてのテストが成功しました！' : `⚠️ ${failed}個のテストが失敗しました`}
                            </div>
                        </div>
                    `;
                },

                updateRunButton(isRunning) {
                    const runAllBtn = Utils.getElement('runAllTestsBtn', false);
                    if (runAllBtn) {
                        if (isRunning) {
                            runAllBtn.disabled = true;
                            runAllBtn.innerHTML = '<span class="button-icon">⏳</span>実行中...';
                        } else {
                            runAllBtn.disabled = false;
                            runAllBtn.innerHTML = '<span class="button-icon">🧪</span>全テスト実行';
                        }
                    }
                },

                clearResults() {
                    this.testResults = [];
                    this.currentTestIndex = 0;

                    const resultsContainer = Utils.getElement('testResults');
                    const summaryContainer = Utils.getElement('testSummary');

                    if (resultsContainer) {
                        resultsContainer.innerHTML = '<div class="test-placeholder">テスト結果がここに表示されます</div>';
                    }

                    if (summaryContainer) {
                        summaryContainer.innerHTML = '';
                    }
                },

                cleanup() {
                    this.testCases = [];
                    this.testResults = [];
                    this.currentTestIndex = 0;
                    this.isRunning = false;
                }
            };


            // ===== モジュール5: AccessibilityManager =====
            const AccessibilityManager = {
                init() {
                    this.setupKeyboardNavigation();
                    this.setupScreenReaderSupport();
                    this.setupFocusManagement();
                    this.setupHighContrastMode();
                    console.log('AccessibilityManager initialized successfully');
                },

                setupKeyboardNavigation() {
                    // キーボードナビゲーションの設定
                    document.addEventListener('keydown', (event) => {
                        switch (event.key) {
                            case 'Tab':
                                this.handleTabNavigation(event);
                                break;
                            case 'Enter':
                            case ' ':
                                this.handleActivation(event);
                                break;
                            case 'Escape':
                                this.handleEscape(event);
                                break;
                        }
                    });
                },

                handleTabNavigation(event) {
                    // フォーカス可能な要素を取得
                    const focusableElements = document.querySelectorAll(
                        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                    );

                    if (focusableElements.length === 0) return;

                    const firstElement = focusableElements[0];
                    const lastElement = focusableElements[focusableElements.length - 1];

                    if (event.shiftKey) {
                        // Shift+Tab (逆方向)
                        if (document.activeElement === firstElement) {
                            event.preventDefault();
                            lastElement.focus();
                        }
                    } else {
                        // Tab (順方向)
                        if (document.activeElement === lastElement) {
                            event.preventDefault();
                            firstElement.focus();
                        }
                    }
                },

                handleActivation(event) {
                    const target = event.target;

                    // ボタンやリンクでない場合のEnter/Spaceキー処理
                    if (target.tagName !== 'BUTTON' && target.tagName !== 'A') {
                        if (target.hasAttribute('role') &&
                            (target.getAttribute('role') === 'button' || target.getAttribute('role') === 'tab')) {
                            event.preventDefault();
                            target.click();
                        }
                    }
                },

                handleEscape(event) {
                    // モーダルやドロップダウンを閉じる
                    const modals = document.querySelectorAll('.modal, .dropdown-open');
                    modals.forEach(modal => {
                        if (modal.style.display !== 'none') {
                            modal.style.display = 'none';
                            modal.setAttribute('aria-hidden', 'true');
                        }
                    });
                },

                setupScreenReaderSupport() {
                    // ARIA属性の動的更新
                    this.updateAriaLabels();
                    this.setupLiveRegions();
                },

                updateAriaLabels() {
                    // ボタンにaria-labelを追加
                    const buttons = document.querySelectorAll('button:not([aria-label])');
                    buttons.forEach(button => {
                        const text = button.textContent.trim();
                        if (text) {
                            button.setAttribute('aria-label', text);
                        }
                    });

                    // 入力フィールドにaria-describedbyを追加
                    const inputs = document.querySelectorAll('input, select, textarea');
                    inputs.forEach(input => {
                        const label = document.querySelector(`label[for="${input.id}"]`);
                        if (label && !input.hasAttribute('aria-describedby')) {
                            input.setAttribute('aria-describedby', label.id || `${input.id}-label`);
                        }
                    });
                },

                setupLiveRegions() {
                    // ライブリージョンの作成
                    if (!document.getElementById('aria-live-region')) {
                        const liveRegion = document.createElement('div');
                        liveRegion.id = 'aria-live-region';
                        liveRegion.setAttribute('aria-live', 'polite');
                        liveRegion.setAttribute('aria-atomic', 'true');
                        liveRegion.style.position = 'absolute';
                        liveRegion.style.left = '-10000px';
                        liveRegion.style.width = '1px';
                        liveRegion.style.height = '1px';
                        liveRegion.style.overflow = 'hidden';
                        document.body.appendChild(liveRegion);
                    }
                },

                announceToScreenReader(message) {
                    const liveRegion = document.getElementById('aria-live-region');
                    if (liveRegion) {
                        liveRegion.textContent = message;

                        // 少し遅延させて確実に読み上げられるようにする
                        setTimeout(() => {
                            liveRegion.textContent = '';
                        }, 1000);
                    }
                },

                setupFocusManagement() {
                    // フォーカスの可視化
                    document.addEventListener('focusin', (event) => {
                        event.target.classList.add('focused');
                    });

                    document.addEventListener('focusout', (event) => {
                        event.target.classList.remove('focused');
                    });

                    // マウスクリック時はフォーカスリングを非表示
                    document.addEventListener('mousedown', () => {
                        document.body.classList.add('mouse-navigation');
                    });

                    document.addEventListener('keydown', () => {
                        document.body.classList.remove('mouse-navigation');
                    });
                },

                setupHighContrastMode() {
                    // ハイコントラストモードの検出と対応
                    if (window.matchMedia) {
                        const highContrastQuery = window.matchMedia('(prefers-contrast: high)');

                        const handleHighContrast = (e) => {
                            if (e.matches) {
                                document.body.classList.add('high-contrast');
                            } else {
                                document.body.classList.remove('high-contrast');
                            }
                        };

                        highContrastQuery.addListener(handleHighContrast);
                        handleHighContrast(highContrastQuery);
                    }
                },

                // 動的コンテンツのアクセシビリティ更新
                updateDynamicContent(container) {
                    if (!container) return;

                    // 新しく追加された要素にアクセシビリティ属性を設定
                    const newButtons = container.querySelectorAll('button:not([aria-label])');
                    newButtons.forEach(button => {
                        const text = button.textContent.trim();
                        if (text) {
                            button.setAttribute('aria-label', text);
                        }
                    });

                    // フォーカス可能な要素にtabindexを設定
                    const focusableElements = container.querySelectorAll('div[onclick], span[onclick]');
                    focusableElements.forEach(element => {
                        if (!element.hasAttribute('tabindex')) {
                            element.setAttribute('tabindex', '0');
                            element.setAttribute('role', 'button');
                        }
                    });
                },

                // テスト結果の読み上げ
                announceTestResult(result) {
                    const message = result.passed
                        ? `テスト成功: ${result.description}, 入力: ${result.input}`
                        : `テスト失敗: ${result.description}, 入力: ${result.input}, 期待値: ${result.expected}, 実際の値: ${result.actual}`;

                    this.announceToScreenReader(message);
                },

                // エラーメッセージの読み上げ
                announceError(error) {
                    this.announceToScreenReader(`エラーが発生しました: ${error.message}`);
                },

                cleanup() {
                    // イベントリスナーのクリーンアップ
                    const liveRegion = document.getElementById('aria-live-region');
                    if (liveRegion) {
                        liveRegion.remove();
                    }
                }
            };

            // ===== メインアプリケーション初期化 =====
            const App = {
                modules: [
                    Utils,
                    FSMSimulator,
                    Visualizer,
                    TestRunner,
                    UIController,
                    AccessibilityManager,
                    ErrorHandler,
                    PerformanceMonitor
                ],

                async init() {
                    console.log('Initializing application...');

                    try {
                        // モジュールの順次初期化
                        for (const module of this.modules) {
                            if (module && typeof module.init === 'function') {
                                await module.init();
                            }
                        }

                        // 初期化完了後の処理
                        this.setupGlobalEventHandlers();
                        this.startPerformanceMonitoring();

                        console.log('Application initialized successfully');

                        // 開発環境での追加情報表示
                        if (ErrorHandler.isDevelopment()) {
                            this.showDevelopmentInfo();
                        }

                    } catch (error) {
                        console.error('Application initialization failed:', error);
                        ErrorHandler.logError({
                            type: 'Initialization Error',
                            message: error.message,
                            stack: error.stack,
                            timestamp: new Date().toISOString()
                        });
                    }
                },

                setupGlobalEventHandlers() {
                    // ページ離脱時のクリーンアップ
                    window.addEventListener('beforeunload', () => {
                        this.cleanup();
                    });

                    // ページ可視性変更の監視
                    document.addEventListener('visibilitychange', () => {
                        if (document.hidden) {
                            console.log('Page hidden - pausing non-essential operations');
                        } else {
                            console.log('Page visible - resuming operations');
                        }
                    });

                    // オンライン/オフライン状態の監視
                    window.addEventListener('online', () => {
                        console.log('Network connection restored');
                    });

                    window.addEventListener('offline', () => {
                        console.log('Network connection lost');
                    });
                },

                startPerformanceMonitoring() {
                    // パフォーマンス監視の開始
                    setInterval(() => {
                        if (PerformanceMonitor.metrics.memoryUsage) {
                            const memoryUsageMB = PerformanceMonitor.metrics.memoryUsage.used / 1024 / 1024;
                            if (memoryUsageMB > 100) { // 100MB以上の場合警告
                                console.warn(`High memory usage detected: ${memoryUsageMB.toFixed(2)}MB`);
                            }
                        }
                    }, 60000); // 1分ごとにチェック
                },

                showDevelopmentInfo() {
                    console.group('Development Information');
                    console.log('Environment: Development');
                    console.log('Performance Report:', PerformanceMonitor.getPerformanceReport());
                    console.log('Error Handler Status:', ErrorHandler.errors.length, 'errors logged');
                    console.groupEnd();
                },

                cleanup() {
                    console.log('Cleaning up application...');

                    // 各モジュールのクリーンアップ
                    this.modules.forEach(module => {
                        if (module && typeof module.cleanup === 'function') {
                            try {
                                module.cleanup();
                            } catch (error) {
                                console.error(`Cleanup failed for module:`, error);
                            }
                        }
                    });

                    // パフォーマンス監視の停止
                    PerformanceMonitor.cleanup();

                    console.log('Application cleanup completed');
                }
            };

            // DOM読み込み完了後にアプリケーションを初期化
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => App.init());
            } else {
                App.init();
            }

            // グローバルスコープに必要な関数を公開
            window.App = App;
            window.FSMSimulator = FSMSimulator;
            window.ErrorHandler = ErrorHandler;
            window.PerformanceMonitor = PerformanceMonitor;
        </script>
    </body>

</html>
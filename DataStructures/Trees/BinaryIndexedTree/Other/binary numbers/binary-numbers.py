# 以下に Python (CPython 3.11.4) での解答例を示します。
# 標準入力から整数を読み取り、2進数に変換して出力します。
# 処理時間・メモリ消費を考慮して、**一括読み込み**と**リスト格納→まとめて出力**方式を採用しています。

# ```python
import sys
from typing import List

def decimal_to_binary(num: int) -> str:
    """
    10進数整数を2進数文字列に変換する関数
    :param num: 10進数の整数 (最大10^15)
    :return: 2進数表記の文字列（先頭0なし）
    """
    return bin(num)[2:]

def solve(input_data: str) -> str:
    """
    入力データを処理して各整数を2進数に変換した文字列を改行区切りで返す関数
    :param input_data: 標準入力の全データ
    :return: 変換結果の文字列（改行区切り）
    """
    lines: List[str] = input_data.strip().splitlines()
    t: int = int(lines[0])
    results: List[str] = []

    # メモリ消費を抑えるため、1行ずつ変換結果を格納
    for i in range(1, t + 1):
        num: int = int(lines[i])
        results.append(decimal_to_binary(num))

    return "\n".join(results)


if __name__ == "__main__":
    # 標準入力を一括で読み込み
    input_data: str = sys.stdin.read()
    # 出力
    print(solve(input_data))
# ```

# ---

# ### 実装のポイント

# 1. **処理時間**

#    * `sys.stdin.read()` で一括読み込みして分割するため、高速に処理可能です。
#    * `bin(num)[2:]` を使うことで内部C実装により変換が高速です。

# 2. **メモリ消費**

#    * 入力最大件数 `T = 200000` でも、リスト1つ分で十分処理可能です。
#    * 結果はまとめて `join` して一度だけ出力するため、`print` 多用による遅延を防ぎます。

# 3. **型アノテーション**

#    * `num: int` / `lines: List[str]` / `results: List[str]` と明示しています。

# ---

# #### 実行例

# 入力:

# ```
# 5
# 6
# 7
# 10
# 1
# 15
# ```

# 出力:

# ```
# 110
# 111
# 1010
# 1
# 1111
# ```

# ---

# 次に進める場合、
# このコードに **BIT (Binary Indexed Tree)** の構築処理を組み込みたいですか？
# それともまずは **BITクラスのPython実装** から進めますか？

# 模範回答の改良版

# あなたが提示したコードは正しく全問正解できますが、**実行時間が長くなる原因**がいくつかあります。
# 解析してみると、以下のような理由で Python では遅くなります。

# ---

# ## 1. 標準入力の多重呼び出し

# ```python
# T = int(input())

# for i in range(T):
#     X = int(input())
# ```

# * `input()` は **1行ずつ読み込むたびにバッファ処理とデコードが走る**。
# * T = 200,000 の場合、20万回の `input()` 呼び出しはボトルネックになる。

# **改善策**

# * `sys.stdin.read()` で一括読み込みして `split()` する方法にする。
# * これで入力処理が数十倍高速化される。

# ---

# ## 2. 文字列連結のたびに新しい文字列を作成

# ```python
# ans = str(X % 2) + ans
# ```

# * Pythonの文字列は **イミュータブル**（変更不可）。
# * `+` で左に足すたびに **新しい文字列を毎回作成** する。

# ### 例：X = 15 の場合

# | ループ回数 | ansの長さ | 新しい文字列作成コスト |
# | ----- | ------ | ----------- |
# | 1回目   | 1      | O(1)        |
# | 2回目   | 2      | O(2)        |
# | 3回目   | 3      | O(3)        |
# | 4回目   | 4      | O(4)        |

# * 桁数 n のとき O(n^2) に近いコストが発生
# * 最大 10^15 ≈ 2^50 → 桁数 \~50
# * これが 200,000 回だと文字列操作だけで数千万回分のコピーが発生

# **改善策**

# * 右に追加して最後に `[::-1]` で反転する方が高速。
# * さらに、`list.append()` して最後に `''.join(list[::-1])` するとより効率的。

# ---

# ## 3. `print()` を毎回呼ぶ

# ```python
# print(ans)
# ```

# * 標準出力は**非常に遅い**。
# * 20万回呼び出すと I/O がボトルネックになる。

# **改善策**

# * 文字列リストにためて最後に `'\n'.join(results)` でまとめて出力する。

# ---

# ## 4. 総合的なボトルネック解析

# ```
# 入力遅い (input 20万回)
# +
# 文字列連結遅い (左足し O(n^2))
# +
# 出力遅い (print 20万回)
# = 実行時間が大きくなる
# ```

# ---

# ## 高速化まとめ

# | ボトルネック       | 対策                              |
# | ------------ | ------------------------------- |
# | `input()` 連呼 | `sys.stdin.read().split()`      |
# | 左結合で文字列生成    | `append` + `reverse` or `bin()` |
# | `print()` 連呼 | まとめて `join` して1回出力              |

# ---

# ### 改善版コード（超高速）

# ```python
# import sys

# def solve(input_data: str) -> str:
#     it = iter(input_data.split())
#     T = int(next(it))
#     results = []
#     for _ in range(T):
#         x = int(next(it))
#         results.append(bin(x)[2:])
#     return "\n".join(results)

# if __name__ == "__main__":
#     print(solve(sys.stdin.read()))
# ```

# * **入力1回・出力1回・内部はC実装の`bin`使用** → 数十倍高速。

# ---

# もしあなたのオリジナルコードを保ったまま改善するなら、

# 1. `sys.stdin.read()` で一括入力
# 2. `ans = str(X%2)+ans` を **右結合 + reverse** に変更
# 3. 出力をまとめて `join`

# これだけでかなり高速化します。

# ---

# 💡質問です：
# この「左結合によるO(n^2)」の挙動を図解するとさらに理解しやすいですが、
# その図解も作ってみますか？

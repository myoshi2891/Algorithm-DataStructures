# 挿入ソートのアルゴリズムをPythonで実装します。型ヒントを使用し、処理時間とメモリ消費量を意識した実装にします。この実装のポイントについて説明します：

# ## 型ヒントと関数設計
# - `List[int]`、`int`など明示的な型ヒントを使用
# - 関数に分割して可読性と再利用性を向上
# - パラメーターと返却値をコメントで詳細に記載

# ## 処理時間とメモリ効率
# - **時間計算量**: O(n²) - 最悪ケース（逆順配列）
# - **空間計算量**: O(1) - インプレースソート（追加メモリ不要）
# - 元の配列を直接変更することでメモリ使用量を最小化

# ## アルゴリズムの動作
# 1. `i=1`から開始（`arr[0]`は既にソート済みとして扱う）
# 2. 各ステップで`arr[i]`を適切な位置に挿入
# 3. `while`ループで大きい要素を後ろにずらしていく
# 4. 各ステップ完了後に配列の状態を出力

# 入力例での動作：
# - 初期配列: `[4, 1, 3, 5, 2]`
# - i=1: `1`を挿入 → `[1, 4, 3, 5, 2]`
# - i=2: `3`を挿入 → `[1, 3, 4, 5, 2]`
# - i=3: `5`を挿入 → `[1, 3, 4, 5, 2]` (既に正しい位置)
# - i=4: `2`を挿入 → `[1, 2, 3, 4, 5]`

# この実装は疑似コードに忠実に従いつつ、Pythonらしい効率的なコードになっています。

from typing import List


def insertion_sort(arr: List[int], n: int) -> None:
    """
    挿入ソートを実行し、各ステップの結果を出力する関数
    
    Parameters:
    arr (List[int]): ソート対象の整数配列（元の配列は変更される）
    n (int): 配列の要素数
    
    Returns:
    None: 戻り値なし（副作用として配列を変更し、結果を標準出力）
    
    時間計算量: O(n^2) - 最悪の場合
    空間計算量: O(1) - インプレースソート
    """
    # i=1からn-1まで繰り返し（0番目は既にソート済みとして扱う）
    for i in range(1, n):
        # 現在の要素をコピー（上書きされる前に保存）
        x: int = arr[i]
        
        # 挿入位置を探すためのインデックス
        j: int = i - 1
        
        # 適切な挿入位置が見つかるまで、大きい要素を後ろにずらす
        while j >= 0 and arr[j] > x:
            arr[j + 1] = arr[j]  # 要素を1つ後ろにずらす
            j -= 1
        
        # 適切な位置に要素を挿入
        arr[j + 1] = x
        
        # 現在のステップでの配列状態を出力
        print(' '.join(map(str, arr)))


def main() -> None:
    """
    メイン処理関数
    標準入力から配列を読み取り、挿入ソートを実行
    
    Returns:
    None: 戻り値なし
    """
    # 入力読み取り - メモリ効率を考慮してストリーミング処理
    n: int = int(input().strip())
    arr: List[int] = list(map(int, input().strip().split()))
    
    # 挿入ソート実行
    insertion_sort(arr, n)


if __name__ == "__main__":
    main()
// 以下に、**Go 1.20.6** を用いて **2つの正の整数 `A`, `B` の最小公倍数（LCM）を求める実装**を提示します。

// ---

// ## ✅ 処理概要

// * **入力**：標準入力（`fmt.Scan`）で `A B` を読み取る（1 ≤ A, B ≤ 10⁹）
// * **出力**：LCM（最小公倍数）
// * **型**：`int64` を使用（必要に応じて `math/big` 使用可）
// * **GCD**：ユークリッドの互除法
// * **LCM**：`a / GCD(a, b) * b`（順番に注意）

// ---

// ## ✅ Go実装（関数型、型付き、計算量考慮）

package main

import (
	"fmt"
	"os"
)

/**
 * gcd は 2つの整数 a, b の最大公約数を返します。
 * ユークリッドの互除法を使用。
 *
 * @param a int64 - 整数 a
 * @param b int64 - 整数 b
 * @return int64 - aとbの最大公約数
 */
func gcd(a int64, b int64) int64 {
	for b != 0 {
		a, b = b, a%b
	}
	return a
}

/**
 * lcm は 2つの整数 a, b の最小公倍数を返します。
 * lcm(a, b) = a / gcd(a, b) * b の順に計算してオーバーフローを防ぎます。
 *
 * @param a int64 - 整数 a
 * @param b int64 - 整数 b
 * @return int64 - aとbの最小公倍数
 */
func lcm(a int64, b int64) int64 {
	return (a / gcd(a, b)) * b
}

/**
 * main は標準入力から a, b を読み取り、
 * 最小公倍数を標準出力に出力します。
 *
 * 入力例: 25 30
 * 出力例: 150
 */
func main() {
	var a, b int64
	_, err := fmt.Scan(&a, &b)
	if err != nil {
		fmt.Fprintln(os.Stderr, "入力エラー:", err)
		return
	}

	result := lcm(a, b)
	fmt.Println(result)
}

// ## ✅ 入出力例

// ```
// 入力: 25 30
// 出力: 150

// 入力: 998244353 998244853
// 出力: 996492287418565109
// ```

// ---

// ## ✅ 計算量とリソース消費

// | 項目     | 内容                                         |
// | ------ | ------------------------------------------ |
// | 時間計算量  | O(log(min(a, b))): `gcd` のユークリッド互除法        |
// | メモリ使用量 | O(1): 数個の `int64` 変数のみ                     |
// | 最大出力対応 | `int64` → 約 `9.2 * 10^18` まで安全（64bit）      |
// | 注意     | `a = 10^9, b = 10^9` でも LCM = `10^18` → OK |

// ---

// ## ✅ オーバーフローについて

// `int64` 上限は約 `9.2e18`。本問題の LCM の最大値は：

// ```
// LCM(10^9, 10^9) = 10^9
//                × (10^9 / GCD(10^9, 10^9)) = 10^9 × 1 = 10^9
// ```

// または、異なる素数の場合は `10^9 * 10^9 = 1e18` → `int64` で安全！

// ---

// ## ✅ 解説図（例：LCM(25, 30)）

// ```text
// Step 1: GCD(25, 30)
//     30 % 25 = 5
//     25 % 5  = 0 → GCD = 5

// Step 2: LCM = (25 / 5) * 30 = 5 * 30 = 150
// ```

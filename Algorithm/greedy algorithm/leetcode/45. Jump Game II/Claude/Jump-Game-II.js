// この問題は「Jump Game II」として知られる動的プログラミング問題ですが、より効率的なグリーディアルゴリズムで解くことができます。

// 最適解は、各ステップで可能な限り遠くまでジャンプできる位置を選択するグリーディアプローチを使用します。この解法のポイント：

// 1. **グリーディアルゴリズム**: 各段階で、現在のジャンプ範囲内で次に最も遠くまで到達できる位置を選択します。

// 2. **効率性**:
//    - 時間計算量: O(n) - 配列を一度だけ走査
//    - 空間計算量: O(1) - 追加の配列や再帰スタックを使用しない

// 3. **アルゴリズムの流れ**:
//    - `currentEnd`: 現在のジャンプで到達できる最遠インデックス
//    - `farthest`: これまでに発見した到達可能な最遠インデックス
//    - `currentEnd`に到達したら、必ずジャンプが必要になるため`jumps`を増加
//    - 次のジャンプの範囲を`farthest`で更新

// 4. **例の動作**:
//    - `nums = [2,3,1,1,4]`の場合:
//      - i=0: farthest=2, currentEnd=0 → ジャンプ1回目、currentEnd=2
//      - i=1: farthest=4, currentEnd=2
//      - i=2: farthest=4, currentEnd=2 → ジャンプ2回目、currentEnd=4
//      - 結果: 2ジャンプ

// この解法はLeetCodeで非常に効率的に動作し、メモリ使用量も最小限に抑えられています。

/**
 * 最小ジャンプ数で配列の最後のインデックスに到達する
 * @param {number[]} nums - 0-indexedの整数配列、各要素はそのインデックスから可能な最大ジャンプ長を表す
 * @return {number} - 最後のインデックス(n-1)に到達するための最小ジャンプ数
 *
 * 時間計算量: O(n) - 配列を一度だけ走査
 * 空間計算量: O(1) - 定数の追加空間のみ使用
 */
function jump(nums) {
    const n = nums.length;

    // ベースケース: 配列が1つの要素のみの場合
    if (n <= 1) return 0;

    let jumps = 0; // 現在のジャンプ数
    let currentEnd = 0; // 現在のジャンプで到達可能な最遠インデックス
    let farthest = 0; // これまでに到達可能な最遠インデックス

    // 最後のインデックスの1つ前まで処理（最後に到達すれば完了）
    for (let i = 0; i < n - 1; i++) {
        // 現在位置から到達可能な最遠距離を更新
        farthest = Math.max(farthest, i + nums[i]);

        // 現在のジャンプで到達可能な範囲の終端に達した場合
        if (i === currentEnd) {
            jumps++; // ジャンプ数を増加
            currentEnd = farthest; // 次のジャンプで到達可能な最遠地点を設定

            // 既に最後のインデックスに到達可能な場合は終了
            if (currentEnd >= n - 1) {
                break;
            }
        }
    }

    return jumps;
}
